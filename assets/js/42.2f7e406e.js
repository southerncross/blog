(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{310:function(t,s,a){"use strict";a.r(s);var n=a(3),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"子类型（subtype）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#子类型（subtype）"}},[t._v("#")]),t._v(" 子类型（subtype）")]),t._v(" "),a("p",[t._v("面向对象编程中，我们可以简单地认为对象就是键值对。")]),t._v(" "),a("p",[t._v("比如直角坐标系中的点（Point）对象：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("y")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("其对应的类型是：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Point")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("假设现在有这样一个对象：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("y")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'red'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("其对应的类型是：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ColoredPoint")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" color"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("可以看到，"),a("code",[t._v("ColoredPoint")]),t._v("包含了"),a("code",[t._v("Point")]),t._v("的全部信息，此外还多了一个color信息，信息越多越具体（特化），所以我们就说"),a("code",[t._v("ColoredPoint")]),t._v("是"),a("code",[t._v("Point")]),t._v("的子类型（subtype）。")]),t._v(" "),a("p",[t._v("这个其实是比较容易理解的，比如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("植物 -> 水果 -> 苹果 -> 黄元帅苹果\n")])])]),a("p",[t._v("越往右，信息越多越具体，右边都是左边的子类型。")]),t._v(" "),a("p",[t._v("因而在面向对象编程中，子类型的对象可以赋值给父类型的对象，即：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" apple"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("Apple "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Apple")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fruit"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("Fruit "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" apple"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("这个过程无需强制类型转换，因为上述子类型的定义符合"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle",target:"_blank",rel:"noopener noreferrer"}},[t._v("里氏替换原则"),a("OutboundLink")],1),t._v("，这样写一定不会出错。")]),t._v(" "),a("blockquote",[a("p",[t._v("里氏替换原则通俗版：子类对象可以在程序中替换父类对象")])]),t._v(" "),a("p",[t._v("关于里氏替换原则，也可以这样理解：父类型是大人，子类型是小孩。现在一群人满满当当挤在电梯里，你可以把一个大人替换成一个小孩，但是反之不行。也就是，更小的类型可以替换更大的类型。")]),t._v(" "),a("h2",{attrs:{id:"协变（covariance）、逆变（contravariance）、不可变（invariance）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协变（covariance）、逆变（contravariance）、不可变（invariance）"}},[t._v("#")]),t._v(" 协变（Covariance）、逆变（Contravariance）、不可变（Invariance）")]),t._v(" "),a("p",[t._v("函数是否也有子类型呢？因为函数有参数和返回值，那我们先用控制变量法，只观察参数类型或返回值类型不同的函数。")]),t._v(" "),a("p",[t._v("首先来看参数类型相同而返回值类型不同的函数：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("drawPoint")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("y")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Point "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("drawRedPoint")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("y")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" RedPoint "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("color")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'red'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("想象一下，如果我们把代码中所有的"),a("code",[t._v("drawPoint")]),t._v("都替换成"),a("code",[t._v("drawRedPoint")]),t._v("，这应该是没有问题的（返回的对象多了一个color字段，没有什么影响），而反之是有问题的。那么根据里氏替换原则，"),a("code",[t._v("drawRedPoint")]),t._v("是"),a("code",[t._v("drawPoint")]),t._v("的子类型。")]),t._v(" "),a("p",[t._v("抽象一下总结出来就是，对于参数类型相同的两个函数，返回值类型越小，函数类型越小。emmmm其实类型可没有大小之分，这里是借用之前电梯的那个例子，总之理解我的意思就好。")]),t._v(" "),a("p",[t._v("再来看看返回值类型相同而参数类型不同的函数：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("logPoint")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("point")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Point")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("point"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("logRedPoint")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("redPoint")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" RedPoint")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("redPoint"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("同样地，如果把代码中所有的"),a("code",[t._v("logRedPoint")]),t._v("替换成"),a("code",[t._v("logPoint")]),t._v("，这应该是不会报错的（原来的参数一定有color字段，现在无所谓了），而反之是有问题的。那么根据里氏替换原则，"),a("code",[t._v("logPoint")]),t._v("是"),a("code",[t._v("logRedPoint")]),t._v("的子类型。")]),t._v(" "),a("p",[t._v("抽象一下总结就是，对于返回值类型相同的参数，参数类型越大，函数类型越小。同理理解我意思就好。")]),t._v(" "),a("p",[t._v("最后，如果函数的参数和返回值类型都不相同，那么我们可以定义：参数类型更大且返回值类型更小的函数类型更小，参数类型更小且返回值类型更大的函数类型更大，其他情况无法比较大小（也就是没有不算子类型）。")]),t._v(" "),a("p",[t._v("用数学符号表示即：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("if s' <= s and t <= t' then s->t <= s'->t'\n")])])]),a("p",[t._v("这里还有一个与之对偶的有趣结论，如果我们把函数固定下来，尝试改变参数和返回值的赋值类型。比如下面这个函数，正常情况下调用该函数，参数是"),a("code",[t._v("Point")]),t._v("类型，而返回值的赋值对象是"),a("code",[t._v("RedPoint")]),t._v("类型：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("point"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Point"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" RedPoint\n")])])]),a("p",[t._v("实际上，如果我们在调用该函数的时候，把参数换成"),a("code",[t._v("RedPoint")]),t._v("类型，或者把返回值的赋值对象换成"),a("code",[t._v("Red")]),t._v("类型，这都是没有问题的。即：")]),t._v(" "),a("ol",[a("li",[t._v("有些地方，我们可以使用比原本设定的类型更小的类型（比如函数的参数）")]),t._v(" "),a("li",[t._v("有些地方，我们可以使用比原本设定的类型更大的类型（比如函数的返回值的赋值变量类型）。")])]),t._v(" "),a("p",[t._v("第一种情况就叫做协变（Covariance），这是最符合直觉的一种场景，第二种情况叫逆变（Contravariance），这个乍一看不太符合直觉。当然除了协变和逆变之外，如果既不能换成大的也不能换成小的，那就叫不可变（Invariance），这种场景也是存在的。")]),t._v(" "),a("p",[t._v("简单的记忆结论就是：参数可协变，返回值可逆变")]),t._v(" "),a("h2",{attrs:{id:"限定泛型（bounded-polymorphism）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#限定泛型（bounded-polymorphism）"}},[t._v("#")]),t._v(" 限定泛型（Bounded Polymorphism）")]),t._v(" "),a("p",[t._v("前文啰嗦了一大堆，总算讲到了正文了，我们先看一看什么叫限定泛型。当然，这里假设你已经知道什么叫泛型了（Polymorphism/Quantification/Generic等）。")]),t._v(" "),a("p",[t._v("限定泛型，的意思就是，限定了的泛型。")]),t._v(" "),a("p",[t._v("比如下面的函数，判断一个东西美不美：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isBeautiful")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("something"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),t._v("\n")])])]),a("p",[t._v("本来泛型T可以是任意类型，比如可以是植物、动物、建筑等，没有任何限制。现在我们像限制一下T只能是动物的子类型，即：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isBeautiful")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" Animal"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("something"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),t._v("\n")])])]),a("p",[t._v("这就叫做限定泛型（Bounded Polymorphism），可以看到，其实就是对参数增加了一个协变。")]),t._v(" "),a("h2",{attrs:{id:"f-bounded-polymorphism"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#f-bounded-polymorphism"}},[t._v("#")]),t._v(" F-bounded Polymorphism")]),t._v(" "),a("p",[t._v("抱歉不知道中文该怎么翻译，有人叫“有界限定泛型”，我觉得不是很贴切。至于为什么叫F-bounded Polymorphism，可以看最初的"),a("a",{attrs:{href:"http://staff.ustc.edu.cn/~xyfeng/teaching/FOPL/lectureNotes/CookFBound89.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("论文"),a("OutboundLink")],1),t._v("，当时的作者也不知道该起什么名字，索性就拿举例子的函数字母F加个前缀吧，于是就叫做F-bounded Polymorphism。")]),t._v(" "),a("p",[t._v("为什么有这么个玩意呢？")]),t._v(" "),a("p",[t._v("回到之前泛型的例子，假如现在的函数是从两个东西里挑出最美的那一个：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pickMostBeautiful")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),t._v("\n")])])]),a("p",[t._v("还是一样，现在想限定一下是从动物中挑选，那么我们会下意识地这样写：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pickMostBeautiful")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" Animal"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),t._v("\n")])])]),a("p",[t._v("因为我们期望达到这样的效果：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" mostBeautiful"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Cat "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pickMostBeautiful")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Cat"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("上面的代码，我们会注意到"),a("code",[t._v("Cat")]),t._v("类型作为了函数返回值赋值的类型，相比于最初的泛型函数，相当于是类型缩小了，也就是发生了协变，而我们知道，函数的返回值赋值变量只能逆变，这这这这这，不是矛盾了吗？！")]),t._v(" "),a("p",[t._v("当当当当，F-bounded Polymorphism登场了：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" mostBeautiful"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("F")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Cat"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("pickMostBeautiful")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Cat"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("这里，把原来的"),a("code",[t._v("Cat")]),t._v("换了个记号"),a("code",[t._v("F[Cat]")]),t._v("，其中的F是一个函数，将一个类型转换成另一个类型。")]),t._v(" "),a("p",[t._v("F的定义是："),a("code",[t._v("F[t] = σ")]),t._v("，且"),a("code",[t._v("t")]),t._v("是"),a("code",[t._v("σ")]),t._v("的子类型。即：σ是来源于t（用F作用于t得到的），而t呢又是来源于σ（子类型的定义），于是σ和t就产生了递归了，这就叫做F-bounded Polymorphism。可见F-bounded Polymorphism其实也是一种Bounded Polymorphism，只是带有递归的Bounded Polymorphism。")]),t._v(" "),a("p",[t._v("回到上面的代码，因为"),a("code",[t._v("Cat")]),t._v("是"),a("code",[t._v("F[Cat]")]),t._v("的子类型，所以是逆变，圆上了。")]),t._v(" "),a("p",[t._v("就好比先有鸡还是先有蛋，这个问题争论起来没有答案，但是在实际情况中不管是先有鸡还是先有蛋，世界都能正常运转，于其纠结于此（compile time），不如引入一个递归的概念把理论说通了，反正现实中（runtime）都很明确了，不打紧。")]),t._v(" "),a("p",[t._v("另一个比较实际的例子是class的this的类型，这里就不啰嗦了，可以看TS的官方文档："),a("a",{attrs:{href:"https://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击这里"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("如果到这里你是一头雾水，那就对了，多琢磨琢磨，找找感觉吧。")]),t._v(" "),a("h2",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"http://staff.ustc.edu.cn/~xyfeng/teaching/FOPL/lectureNotes/CookFBound89.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("F-Bounded Polymorphism for Object-Oriented Programming"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://courses.cs.washington.edu/courses/cse505/99au/oo/f-bounded.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Very Rough Notes on F-Bounded Polymorphism"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)",target:"_blank",rel:"noopener noreferrer"}},[t._v("Covariance and contravariance"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://docs.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance",target:"_blank",rel:"noopener noreferrer"}},[t._v("泛型中的协变和逆变"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle",target:"_blank",rel:"noopener noreferrer"}},[t._v("Liskov substitution principle"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"http://codingwithstyle.blogspot.com/2015/07/f-bounded-polymorphism.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("F-Bounded Polymorphism in Java"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://work.tinou.com/2009/07/wtf-is-fbounded-polymorphism.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("WTF is F-Bounded Polymorphism"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Bounded_quantification",target:"_blank",rel:"noopener noreferrer"}},[t._v("Bounded quantification"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);