<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>国际化学到的东西 | Lishunyang Theme</title>
    <meta name="description" content="Lishunyang&#39;s Blog">
    <link rel="icon" type="image/png" href="/assets/favicon.png">
    
    <link rel="preload" href="/assets/css/0.styles.69785f0f.css" as="style"><link rel="preload" href="/assets/js/app.00c21874.js" as="script"><link rel="preload" href="/assets/js/3.162ce812.js" as="script"><link rel="preload" href="/assets/js/10.0b34055a.js" as="script"><link rel="prefetch" href="/assets/js/1.46c9c9e3.js"><link rel="prefetch" href="/assets/js/11.46c0312d.js"><link rel="prefetch" href="/assets/js/12.f766b72d.js"><link rel="prefetch" href="/assets/js/13.20058293.js"><link rel="prefetch" href="/assets/js/14.7bbe34ee.js"><link rel="prefetch" href="/assets/js/15.fe9e1c79.js"><link rel="prefetch" href="/assets/js/16.1c4131f6.js"><link rel="prefetch" href="/assets/js/17.5e581b15.js"><link rel="prefetch" href="/assets/js/4.5978926c.js"><link rel="prefetch" href="/assets/js/5.ab067b9c.js"><link rel="prefetch" href="/assets/js/6.e16c7064.js"><link rel="prefetch" href="/assets/js/7.829ba662.js"><link rel="prefetch" href="/assets/js/8.64830bfc.js"><link rel="prefetch" href="/assets/js/9.cf4fc754.js">
    <link rel="stylesheet" href="/assets/css/0.styles.69785f0f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-v-58159f8d><ul class="container" data-v-397d2b85 data-v-58159f8d><li class="title" data-v-397d2b85><a href="/" data-v-397d2b85><img src="/assets/img/avatar.cf743a85.jpg" class="avatar" data-v-397d2b85>Lishunyang's Blog</a></li> <li class="item" data-v-397d2b85><a href="https://github.com/southerncross" data-v-397d2b85><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpFNTE3OEEyQTk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpFNTE3OEEyQjk5QTAxMUUyOUExNUJDMTA0NkE4OTA0RCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTI4OTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTI5OTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+m4QGuQAAAyRJREFUeNrEl21ojWEYx895TDPbMNlBK46IUiNmPvHBSUjaqc0H8pF5+aDUKPEBqU2NhRQpX5Rv5jWlDIWlMCv7MMSWsWwmb3tpXub4XXWdPHvc9/Gc41nu+nedc7/8r/99PffLdYdDPsvkwsgkTBwsA/PADJCnzX2gHTwBt8Hl7p537/3whn04XoDZDcpBlk+9P8AFcAghzRkJwPF4zGGw0Y9QS0mAM2AnQj77FqCzrtcwB1Hk81SYojHK4DyGuQ6mhIIrBWB9Xm7ug/6B/nZrBHBegrkFxoVGpnwBMSLR9EcEcC4qb8pP14BWcBcUgewMnF3T34VqhWMFkThLJAalwnENOAKiHpJq1FZgI2AT6HZtuxZwR9GidSHtI30jOrbawxlVX78/AbNfhHlomEUJJI89O2MqeE79T8/nk8nMBm/dK576hZgmA3cp/R4l9/UeSxiHLVIlNm4nFfT0bxyuIj7LHRTKai+zdJobwMKzcZSJb0ePV5PKN+BqAAKE47UlMnERELMM3EdYP/yrd+XYb2mOiYBiQ8OQnoRBlXrl9JZix7D1pHTazu4MoyBcnYamqAjIMTR8G4FT8LuhLsexXYYjICBiqhQBvYb6fLZIJCjPypVvaOoVAW2WcasCnL2Nq82xHJNSqlCeFcDshaPK0twkAhosjZL31QYw+1rlMpWGMArl23SBsZZO58F2tlJXmjOXS+s4WGvpMiBJT/I2PInZ6lIs9/hBsNS1hS6BG0DSqmYEDRlCXQrmy50P1oDRKTSegmNbUsA0zDMwRhPJXeCE3vWLPQMvan6X8AgIa1vcR4AkGZkDR4ejJ1UHpsaVI0g2LInpOsNFUud1rhxSV+fzC9Woz2EZkWQuja7/B+jUrgtIMpy9YCW4n4K41YfzRneW5E1KJTe4B2Zq1Q5EHEtj4U3AfEzR5SVY4l7QYQPJdN2as7RKBF0BPZqqH4VgMAMBL8Byxr7y8zCZiDlnOcEKIPmUpgB5Z2ww5RdOiiRiNajUmWda5IG6WbhsyY2fx6m8gLcoJDJFkH219M3We1+cnda93pfycZpIJEL/s/wSYADmOAwAQgdpBAAAAABJRU5ErkJggg==" class="github" data-v-397d2b85></a></li></ul> <div class="main" data-v-58159f8d><div class="container" data-v-7debe042 data-v-58159f8d><div class="header" data-v-7debe042><h1 class="title" data-v-7debe042>国际化学到的东西</h1> <div class="date" data-v-7debe042>2019/10/6</div></div> <div class="content" data-v-7debe042><div class="content__default" data-v-7debe042><p>记录一下最近一段时间做的前端国际化遇到的问题。</p> <h2 id="挑选一款好用的国际化库"><a href="#挑选一款好用的国际化库" class="header-anchor">#</a> 挑选一款好用的国际化库</h2> <p>国际化必须的几个过程是：构造字典、翻译、字符串替换，任何翻译库都需要解决这几个核心问题。所以可以对比这几个过程的写法来提供一些参考，API越简单越好，自动化程度越高越好，代码侵入性越低越好。</p> <p>首先说说API越简单越好，这个很容易理解，API越多，用法越复杂，开发者越懵逼，越容易产生不当使用。</p> <p>自动化程度越高越好，典型的场景是字典的构造，如果是手动构造字典，那这个成本将会是巨大的，所以正常做法应该是有脚本自动分析代码extract出待翻译的字典，以及处理好后续翻译内容的update。如果国际化库不带这个功能，建议你换一个，或者自己撸一套cli工具。</p> <p>代码侵入性越小越好，这主要指的是像linguijs这个框架会引入自己的babel-plugin，从语法层面魔改了js，虽然极大简化了手写代码的工作量，但是让库的切换，或者升级babel版本变得更加困难。</p> <h2 id="国际化与禁止用中文做状态码"><a href="#国际化与禁止用中文做状态码" class="header-anchor">#</a> 国际化与禁止用中文做状态码</h2> <blockquote><p>代码规范：禁止用中文做状态码</p></blockquote> <p>现在考考你，上面这条规范的意义是什么？</p> <p>很早以前我并不理解为什么要有这样一个规定。因为从编译器或runtime的角度来说，中文和英文只不过是不同unicode的编码罢了。既然都是string，凭什么英文可以做状态码，中文不可以呢？而且中文的可读性更好，表达能力更强，用中文做状态码连注释都省了。</p> <p>后来接触javascript多了，明白javascript对非BMP字符的处理能力有缺陷，这似乎可以作为一个理由，但那只是javascript引擎的问题，可这个编程规范似乎对各种编程语言都适用，所以一定还有什么别的原因。</p> <p>一直到最近做国际化的东西，我才突然明白这个规则的意义。这个规则其实有很多场景下的变种，他们本质上都是想表达“逻辑与展示应当分离”这个意思。到底什么意思呢？举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">===</span> <span class="token string">'成功'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这里是逻辑</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里是展示</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是一个<strong>展示与逻辑混在一起的例子</strong>，代码中<code>status</code>既参与了逻辑（if条件）又参与了展示（conosle.log)。这种做法就是属于不好的例子。假如我们想修改一下文案，把<code>status</code>的值从<code>成功</code>换成<code>通过</code>，为了保证逻辑正确，就同时也要修改逻辑部分，把if条件也改了。</p> <p>正确的做法是“展示与逻辑分离”，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">===</span> <span class="token constant">STATUS_SUCCESS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这里是逻辑</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里是展示</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样，如果要改文案，只需要将<code>console.log</code>处的文本变一下就行了。</p> <p>当然这只是一个非常简单的例子，实际代码可能有非常多的变种，但核心思想都是一样的的，即：“展示与逻辑分离”。那这与不能用中文做状态码有什么关系呢？这是因为如果中文做了状态码，那么这种代码会“诱惑”开发者写出展示与逻辑混合在一起的代码，但如果状态码是英文或数字，那么开发者就没有选择把展示和逻辑分开写。比如上面的例子，如果status的取值只可能是0，1之类的数字，那肯定不会不会出现混合的代码了。</p> <p>现在说回国际化，国际化需要对所有展示的部分做修改，如果代码是展示与逻辑分离的，那么我们只需要改动展示的部分即可，但如果代码是展示与逻辑混在一起的，那很不幸，要该的地方就非常不可控了。</p> <h2 id="好的eslint规则能使国际化效率提升非常非常多"><a href="#好的eslint规则能使国际化效率提升非常非常多" class="header-anchor">#</a> 好的eslint规则能使国际化效率提升非常非常多</h2> <p>对大型项目做国际化最头疼的是找出那些“未国际化”的地方，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token parameter">thing</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'成功！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- 这里是需要国际化的地方</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个一个文件找效率太低了，而且极易出现遗漏，所以你需要一个工具能帮你快速找出哪些地方没有国际化。eslint规则恰好可以用来做这个事情。</p> <p>那什么样的代码算是需要国际化的呢？一个简单的规则是：带有中文的地方。所以你的eslint规则甚至可以单纯用正则匹配中文即可。</p> <p>甚至可以再写一个vscode插件与elisnt规则一起配合做一些事情。</p> <h2 id="pseudo-translation意义不大"><a href="#pseudo-translation意义不大" class="header-anchor">#</a> pseudo-translation意义不大</h2> <p>做国际化之前看过一些文章，里面提到了pseudo-translation这种技术，大致原理是使用一些自动化的方法将代码中的文本替换为一些待翻译的语言字符，用来快速检测UI是否可能需要调整。</p> <p>为什么会有这个过程呢？这主要是因为翻译文本需要专业的翻译团队，而高质量的翻译需要时间（包括翻译、专业人士审校等流程），比如5000句话可能要翻译3周时间。如果等翻译完成了再检查UI，周期太长，为了能并行翻译和UI调整两个动作，就需要一种快速“翻译”的方式，这种方式就是pseudo-translation。</p> <p>一开始，我写了一些自动化脚本将中文替换成了对应的拼音（毕竟拼音也算是要英文字符），勉强实现pseudo-translation的效果。效果嘛自然差强人意，只能说聊胜于无。</p> <p>后来，受钉钉自动翻译功能的启发，我把拼音改成了调用百度翻译API得到机器翻译的英文。这下像那么回事了，别说有些地方翻译的效果还不错，我也颇得意了一阵子。</p> <p>再后来有一天，从同事那里偶然得知chrome浏览器的自动翻译功能，可以完全自动翻译页面，不仅是自动的，而且效果还更好，我晕，早知道直接这样翻译得了，要什么pseudo-translation，甚至国际化工作都不需要做了。</p> <p>然而更大的打击还在后头，等我做完了pseudo-translation，准备让设计团队看看UI如何调整，没想到设计团队对这个行为表现出了强烈的抵触。因为在他们看来，这种pseudo-translation并不是最终的翻译文案，即使现在检查一遍UI并做一些调整，等真正的翻译给出来以后，还要再检查一遍，相当于要做两遍一样的的事情，所以他们不同意。于是pseudo-translation自始至终都没有真正推行过。</p> <p>总之，pseudo-translation意义不大，如果真的需要，用chrome浏览器自动翻译就行了（捂脸）。</p> <h2 id="中文做源语言，有好有坏"><a href="#中文做源语言，有好有坏" class="header-anchor">#</a> 中文做源语言，有好有坏</h2> <p>假如国际化是从A语言翻译到B语言，那么我们称A语言为源语言，B语言为目标语言。</p> <p>中文的语法非常简洁，没有大小写、时态、名词单复数、序数、语序这些乱七八糟的玩意儿，在做源语言的时候反倒有时候会带来一些麻烦。举个例子，“申请”有两种意思，一种是动词，一种是名词，而中文都是一个词，英文却是两个词（apply和application）。假设我们是从英文翻译到中文，那没问题，无论是哪种情况都能准确翻译，但是从中文翻译到英文就必须依靠上下文环境才能区分了，有时候遇到没有上下文环境的情况，确实比较麻烦。</p> <p>所谓：由俭入奢易，由奢入俭难，讲的正是这个道理。</p> <p>但是，中文做源语言也无形中带来了一个好处，什么呢？就是待翻译的地方极其明显。我们基本只要把代码中所有出现中文的地方过滤一遍就可以了。因为代码是基于英文字母的，中文无形中被突出了。假如我们是英文做源语言，如何区分哪些地方应该翻译将会是一件比较麻烦的事情，哈哈哈哈。</p> <h2 id="精简待翻译的文本"><a href="#精简待翻译的文本" class="header-anchor">#</a> 精简待翻译的文本</h2> <p>在国际化的过程中，我发现我们的代码有很多这样的待翻译的内容：</p> <div class="language- extra-class"><pre class="language-text"><code>创建申请成功
添加部门成功
移动阶段成功
安排面试成功
...
</code></pre></div><p>这些文本都是用来描述操作状态的，其实他们想表达的意思都是“操作成功了”，但每个地方的文本都不一样，都需要独立翻译，且增大了翻译包的体积。在不影响用户体验的情况下，这些文本其实都可以简化成————操作成功。</p> <h2 id="国际化带来的ui调整非常多"><a href="#国际化带来的ui调整非常多" class="header-anchor">#</a> 国际化带来的UI调整非常多</h2> <p>我知道国际化可能会让某些UI的样式出现问题，但没想到会有这么多问题。我们翻译了5000处文本，UI上需要调整的问题大大小小报了超过200个，远超预期，所以后续还花了很多时间做UI的修复。</p> <p>这些问题也暴露出来了一些CSS样式的书写缺陷，比如有些地方写得太死，宽度高度固定，不能很好兼容到不同的文本长度。还有些地方使用了line-height做垂直居中，结果文字长度增加后变成两行，行间距变得极其诡异。</p> <p>总之各种错位、溢出问题。</p> <h2 id="翻译文本也需要优化"><a href="#翻译文本也需要优化" class="header-anchor">#</a> 翻译文本也需要优化</h2> <p>国际化翻译的过程是这样的，提取出代码中需要翻译的地方，然后将这些待翻译的内容交给翻译团队做。这里有个问题，那就是翻译团队拿到的是纯文本，没有上下文和UI信息，所以即使是歪果仁翻译的可能出现不准确的情况。</p> <p>举个例子，我们要翻译这么一段文本“推荐人于XXX时间操作”，这个推荐人是什么意思？结合业务看，是指内推人还是猎头？实际上两者都不是，它指的是“推荐到其他职位”的那个操作人，也就是HR。这种例子从实际情况上看，虽然出现的频率不高，但是林子大了什么鸟都有，基数大了出现的次数也不少。而且这种例子只能通过人工一个一个校正。</p> <p>说到校正，这里还有一个问题，即翻译文本如何对应UI。我们在拿到翻译文本的时候可以一并拿到这个文本所在的代码文件，对于开发人员这来说，这个信息基本可以确定这个文本所属的业务逻辑以及UI，但是对于非开发人员这来说，这个信息没用，因为他们不理解代码。不幸的是，负责校正翻译文案的人往往不是开发人员，所以校正工作本身就好像蒙住了眼睛一样，无法高效且准确地完成。</p> <p>至于这个问题如何克服，目前还没有找到合适的方法。</p> <h2 id="babel-plugin的坑（linguijs）"><a href="#babel-plugin的坑（linguijs）" class="header-anchor">#</a> babel-plugin的坑（linguijs）</h2> <p>这一点就与具体的国际化实现方式有关了，我们用的是lingui-js这个库做国际化的，这个库会先用babel-plugin对代码做一次预处理。将一些国际化的简写替换成完整写法，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 源代码</span>
i18n<span class="token punctuation">.</span>t<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">喜欢</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>sport<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>

<span class="token comment">// transform后的结果</span>
i18n<span class="token punctuation">.</span><span class="token function">_</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">{0}喜欢{1}</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> sport <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这本是一个方便开发者的特性，但某些场景下遇到了严重的问题。因为做这个transform的babel-plugin与es6-plugin产生了一些微妙的不好的化学反应。</p> <p>这是因为babel在做transform的时候，只会遍历一次ATS，然后针对每个节点依次应用各种plugin。假如现在有两个plugin，一个处理专门处理A类型的节点，一个会把B类型的节点转换成A类型的节点。如果babel先遍历了B类型的节点，再遍历A类型的节点，那么就没有问题，但假如babel先遍历了A类型的节点（第一个plugin生效了），然后遍历B类型的节点（第二个plugin把B类型转换成了A类型），因为A类型的节点已经遍历过了，不会再生效了，所以这个A类型的节点将不会被第一个plugin处理。结果就得到了错误的转换结果。</p> <p>针对这个问题，其实没有什么解决办法，除非修改babel的执行逻辑，但这基本是不可能的事情，而且这种问题通常只有在运行时才会暴露，非常难发现。</p> <p>唯一的解决办法就是不要用babel-plugin，babel-plugin越少越好。</p> <h2 id="支持局部翻译，做好灰度测试"><a href="#支持局部翻译，做好灰度测试" class="header-anchor">#</a> 支持局部翻译，做好灰度测试</h2> <p>国际化不是一个小工程，它对整个系统带来的改变是非常巨大的。如果指望国际化全部翻译完成再上线，回归范围将变得无比庞大，风险是不可控的。</p> <p>为了控制风险，我们必须一小部分一小部分地实现国际化，小步快跑。改一部分测一部分再上线一部分。为了做到这一点，必须要有灰度发布的能力，不完整的国际化UI仅对测试账号开放，方便测试。等所有国际化工作完成之后在正式开放给其他用户。</p> <p>其实对于代码重构也是一样，不要想着翻天覆地的大重构，你要考虑测试同事们的感受。</p> <h2 id="国际化可以用来检测css水平"><a href="#国际化可以用来检测css水平" class="header-anchor">#</a> 国际化可以用来检测CSS水平</h2> <p>这算是国际化带来的一个启发吧，如果你想面试前端工程师，或者想考察前端工程师的CSS水平，那就让他写一个稍微复杂点的页面吧，然后用chrome的翻译功能转换成英文，如果页面样式乱得一塌糊涂，说明CSS写得不够灵活，反之说明CSS水平高，哈哈哈哈。</p></div></div></div></div> <div class="container" data-v-5d7cf863 data-v-58159f8d>
  Designed by Lishunyang | All right reserved
</div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.00c21874.js" defer></script><script src="/assets/js/3.162ce812.js" defer></script><script src="/assets/js/10.0b34055a.js" defer></script>
  </body>
</html>
