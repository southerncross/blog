<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>javascript的unicode问题 | Lishunyang&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" type="image/png" href="/blog/favicon.png">
    <meta name="description" content="Lishunyang&#39;s Blog">
    <meta name="keywords" content="Javascript,HTTP,Nodejs,React">
    
    <link rel="preload" href="/blog/assets/css/0.styles.102d8b8d.css" as="style"><link rel="preload" href="/blog/assets/js/app.a48c4f56.js" as="script"><link rel="preload" href="/blog/assets/js/2.e0432708.js" as="script"><link rel="preload" href="/blog/assets/js/36.920da182.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.102d8b8d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-v-ad494eec><ul class="container" data-v-26d88251 data-v-ad494eec><li class="title" data-v-26d88251><a href="/blog/" data-v-26d88251><img src="/blog/assets/img/avatar.cf743a85.jpg" class="avatar" data-v-26d88251>Lishunyang's Blog</a></li> <li class="item" data-v-26d88251><a href="/about.html" data-v-26d88251>About</a></li></ul> <div class="main" data-v-ad494eec><div class="container" data-v-63da4bd6 data-v-ad494eec><div class="header" data-v-63da4bd6><h1 class="title" data-v-63da4bd6>javascript的unicode问题</h1> <div class="date-and-tags" data-v-63da4bd6><span class="date" data-v-63da4bd6>2019/6/28</span> <span class="tags" data-v-63da4bd6><span class="tag" data-v-63da4bd6>javascript</span><span class="tag" data-v-63da4bd6>unicode</span></span></div></div> <ul class="sidebar" data-v-63da4bd6><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#unicode基础" data-v-63da4bd6>Unicode基础</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#转义序列" data-v-63da4bd6>转义序列</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#数一数javascript中字符串有多少个unicode符号" data-v-63da4bd6>数一数Javascript中字符串有多少个Unicode符号</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#数一数javascript中字符串有多少个非bmp符号" data-v-63da4bd6>数一数Javascript中字符串有多少个非BMP符号</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#哪些长得很相似的符号" data-v-63da4bd6>哪些长得很相似的符号</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#好多个组合标记" data-v-63da4bd6>好多个组合标记</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#其他类型的符号" data-v-63da4bd6>其他类型的符号</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#在javascript中将字符串反过来" data-v-63da4bd6>在Javascript中将字符串反过来</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#字符串方法中的unicode问题" data-v-63da4bd6>字符串方法中的Unicode问题</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#unicode对正则表达式的影响" data-v-63da4bd6>Unicode对正则表达式的影响</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#生产环境中的bug以及如何避免" data-v-63da4bd6>生产环境中的bug以及如何避免</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2019/06/javascript-has-a-unicode-problem.html#the-pile-of-poo-test" data-v-63da4bd6>The Pile of Poo Test</a></li></ul> <div class="content" data-v-63da4bd6><div class="content__default" data-v-63da4bd6><p>本文翻译自https://mathiasbynens.be/notes/javascript-unicode</p> <hr> <p>Javascript处理Unicode的方式，说实话比较迷。所以这篇文章主要针对这个问题做一些解释，另外看看es6是怎么改进的。</p> <h2 id="unicode基础"><a href="#unicode基础" class="header-anchor">#</a> Unicode基础</h2> <p>在我们继续深入讨论之前，让我们先拉平一下Unicode的认知。</p> <p>理解Unicode的最简单那的方式就是将它想象成一个数据库，里面存着各式各样的符号以及他们对应的唯一id，这个id被叫做code point，此外还存了他们唯一的名字。这样，当我们要表达某个符号的时候，只要给出对应的code point就可以了。比如：</p> <p>当我们说：U+0041，别人就知道我们想要表达的是符号A
当我们说：U+1F4A9，别人就知道我们想要表达的符号是💩</p> <p>Code point通常都是以U+开头的十六进制数字表示，至少有4位，不足的会在前面补0。</p> <p>Code point的范围是U+0000到U+10FFFF，可以容纳超过110万个字符。为了合理组织和利用，Unicode将这个范围划分成了17个部分（Plane），每个部分大约有6万5前个字符。</p> <p>第一个部分（U+0000至U+FFFF），叫做Basic Multilingual Plane（BMP）。这是最重要的一个部分，因为它包含了绝大多数常用的符号。如果你是在用英语写作，那你很有可能不会用到BMP之外的符号。跟其他分区一样，这个分区也有大约6晚5千个字符。</p> <p>除了BMP，剩下的部分（U+010000至U+10FFFF）大概有110万个字符。属于这部分的分区被称作增补分区（supplementary planes或astral planes）。</p> <p>很容易判断一个字符是否来自增补分区，那就是看它对应的十六进制数字的位数是否超过了4位。</p> <p>好了，现在我们已经有了Unicode常识，接下来看看Javascript是如何处理字符串的。</p> <h2 id="转义序列"><a href="#转义序列" class="header-anchor">#</a> 转义序列</h2> <p>你应该见过这种东西：</p> <div class="language- extra-class"><pre class="language-text"><code>&gt;&gt; '\x41\x42\x43'
'ABC'

&gt;&gt; '\x61\x62\x63'
'abc'
</code></pre></div><p>这种东西被称作“十六进制转义序列”（hexadecimal escape sequence）。它是由2位的十六进制数字来对应code point的，例如\x41对应U+0041（大写字母A）。因为只有2位，所以它只能用来对应U+0000到U+00FF的code point。</p> <p>另一种常见的转移字符形式是这样的：</p> <div class="language- extra-class"><pre class="language-text"><code>&gt;&gt; '\u0041\u0042\u0043'
'ABC'

&gt;&gt; 'I \u2661 JavaScript!'
'I ♡ JavaScript!'
</code></pre></div><p>这种东西被称作“Unicode转义序列“。它是由4位的十六进制数字来表示code point的。例如\u2261表示的是U+2261（心型符号）。因为是4位，所以能表示U+0000到U+FFFF范围的code point，也就是完整的BMP。</p> <p>现在问题出现了，如果是非BMP字符（增补分区），我们需要超过4位的十六进制数字，那么要怎么做呢？</p> <p>在ES6中，事情就很好办了。因为ES6引入了一种新的转移序列，叫做“Unicode code point转义序列”。举个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>&gt;&gt; '\u{41}\u{42}\u{43}'
'ABC'

&gt;&gt; '\u{1F4A9}'
'💩' // U+1F4A9 PILE OF POO
</code></pre></div><p>可以看到，在大括号中间，你可以使用最多6个十六进制数字，足够表示所有的Unicode code point了。也就是说，你可以用这种方式表示任意Unicode字符。</p> <p>对于ES5甚至更老的环境，为了兼容性，有个倒霉的解决方式叫做“替换对儿”（surrogate pairs）：</p> <div class="language- extra-class"><pre class="language-text"><code>&gt;&gt; '\uD83D\uDCA9'
'💩' // U+1F4A9 PILE OF POO
</code></pre></div><p>如上所示，一个code point会被拆分成两部分，不妨就叫做surrogate code point，换句话说，surrogate code point合在一起共同表示一个原始code point。</p> <p>需要注意的是，surrogate code point跟原始code point长得很不一样。这两者是通过运算公式相互转换的。</p> <p>通过使用surrogate pairs，现在我们总算是可以表达非BMP字符了。但问题是，用一个转移字符表示BMP和用两个转移字符表示非BMP，这两种方式在写法上没任何区别，十分令人迷惑，并且引发了一系列问题。</p> <h2 id="数一数javascript中字符串有多少个unicode符号"><a href="#数一数javascript中字符串有多少个unicode符号" class="header-anchor">#</a> 数一数Javascript中字符串有多少个Unicode符号</h2> <p>假设你要计算一个给定字符串的长度，你会怎么做呢？</p> <div class="language- extra-class"><pre class="language-text"><code>&gt;&gt; 'A'.length // U+0041 LATIN CAPITAL LETTER A
1

&gt;&gt; 'A' == '\u0041'
true

&gt;&gt; 'B'.length // U+0042 LATIN CAPITAL LETTER B
1

&gt;&gt; 'B' == '\u0042'
true
</code></pre></div><p>在上面的例子中，字符串的.length属性反应的是字符串中字母的个数。如果我们使用转移序列表示这些字符，那么一个字符刚好对应一个转义符号。但有时候却不是这样：</p> <div class="language- extra-class"><pre class="language-text"><code>&gt;&gt; '𝐀'.length // U+1D400 MATHEMATICAL BOLD CAPITAL A
2

&gt;&gt; '𝐀' == '\uD835\uDC00'
true

&gt;&gt; '𝐁'.length // U+1D401 MATHEMATICAL BOLD CAPITAL B
2

&gt;&gt; '𝐁' == '\uD835\uDC01'
true

&gt;&gt; '💩'.length // U+1F4A9 PILE OF POO
2

&gt;&gt; '💩' == '\uD83D\uDCA9'
true
</code></pre></div><p>这是因为Javascript使用surrogate pairs表示了非BMP字符，并且这些“半个surrogate pairs”看上去就像一个独立的字符一样。这种结果非常令人迷惑，因为肉眼看上去无法分辨，只知道是一堆Unicode字符。</p> <h2 id="数一数javascript中字符串有多少个非bmp符号"><a href="#数一数javascript中字符串有多少个非bmp符号" class="header-anchor">#</a> 数一数Javascript中字符串有多少个非BMP符号</h2> <p>回到刚才那个问题，如何精确计算Javascript字符串中有多少个Unicode符号呢？现在我们知道了，关键是要正确识别出其中哪些是surrogate pairs，然后把这些pairs当成是一个符号。下面是一个简单的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> regexAstralSymbols <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\uD800-\uDBFF][\uDC00-\uDFFF]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">countSymbols</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> string
    <span class="token comment">// Replace every surrogate pair with a BMP symbol.</span>
    <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>regexAstralSymbols<span class="token punctuation">,</span> <span class="token string">'_'</span><span class="token punctuation">)</span>
    <span class="token comment">// …and *then* get the length.</span>
    <span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者你可以用Punycode.js这个库（随node一起发布），先把Javascript字符串转换成一组Unicode code point，然后统计有多少个code point，就像这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">countSymbols</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> punycode<span class="token punctuation">.</span>ucs2<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果是ES6，你还可以用<code>Array.from</code>，它会使用字符串迭代器对字符串进行切割，数组中每个元素都是一个符号。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">countSymbols</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>或者使用spread运算符</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">countSymbols</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>string<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用上面任意一种方法，我们都能够正确计算出字符串中有多少个符号。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token function">countSymbols</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token comment">// U+0041 LATIN CAPITAL LETTER A</span>
<span class="token number">1</span>

<span class="token operator">&gt;&gt;</span> <span class="token function">countSymbols</span><span class="token punctuation">(</span><span class="token string">'𝐀'</span><span class="token punctuation">)</span> <span class="token comment">// U+1D400 MATHEMATICAL BOLD CAPITAL A</span>
<span class="token number">1</span>

<span class="token operator">&gt;&gt;</span> <span class="token function">countSymbols</span><span class="token punctuation">(</span><span class="token string">'💩'</span><span class="token punctuation">)</span> <span class="token comment">// U+1F4A9 PILE OF POO</span>
<span class="token number">1</span>
</code></pre></div><h2 id="哪些长得很相似的符号"><a href="#哪些长得很相似的符号" class="header-anchor">#</a> 哪些长得很相似的符号</h2> <p>还有更头疼的事情，计算字符串中符号的数量实际上复杂多了。比如下面这个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token string">'mañana'</span> <span class="token operator">==</span> <span class="token string">'mañana'</span>
<span class="token boolean">false</span>
</code></pre></div><p>Javascript说这两个字符串是不一样的，但是明明看着没区别呀，这是怎么回事！</p> <p><img src="https://mathiasbynens.be/_img/javascript-unicode/js-escapes-manana.png" alt=""></p> <p>使用<a href="https://mothereff.in/js-escapes#1ma%C3%B1ana%20man%CC%83ana" target="_blank" rel="noopener noreferrer">escape tool<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>这个工具，我们就能找到原因了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token string">'ma\xF1ana'</span> <span class="token operator">==</span> <span class="token string">'man\u0303ana'</span>
<span class="token boolean">false</span>

<span class="token operator">&gt;&gt;</span> <span class="token string">'ma\xF1ana'</span><span class="token punctuation">.</span>length
<span class="token number">6</span>

<span class="token operator">&gt;&gt;</span> <span class="token string">'man\u0303ana'</span><span class="token punctuation">.</span>length
<span class="token number">7</span>
</code></pre></div><p>第一个字符串包含了一个U+00F1 LATIN SMALL LETTER N WITH TILDE，但是第二个字符串包含有两个独立的code point（U+006E LATIN SMALL LETTER N和U+0303 COMBINING TILDE）组合在一起形成一样的图案。这就是为什么明明他们看上去一样，<code>.length</code>却不一样。</p> <p>但是，如果你按照人类的正常思维去数到底有多少符号，上面两个字符串的结果都是6，这又是什么鬼呢？</p> <p>在ES6中，答案是很简单的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">countSymbolsPedantically</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Unicode Normalization, NFC form, to account for lookalikes:</span>
  <span class="token keyword">var</span> normalized <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token string">'NFC'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Account for astral symbols / surrogates, just like we did before:</span>
  <span class="token keyword">return</span> punycode<span class="token punctuation">.</span>ucs2<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>normalized<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个<code>normalize</code>方法的效果是使所有长得类似的Unicode都统一成一个（Unicode normalization）。如果一个code point对应的符号跟两个code points对应的符号组合在一起长得差不多，那么他们就会被统一成一个code point。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token function">countSymbolsPedantically</span><span class="token punctuation">(</span><span class="token string">'mañana'</span><span class="token punctuation">)</span> <span class="token comment">// U+00F1</span>
<span class="token number">6</span>
<span class="token operator">&gt;&gt;</span> <span class="token function">countSymbolsPedantically</span><span class="token punctuation">(</span><span class="token string">'mañana'</span><span class="token punctuation">)</span> <span class="token comment">// U+006E + U+0303</span>
<span class="token number">6</span>
</code></pre></div><p>对于ES5和更老的环境，可以使用polyfill达到同样的功能。</p> <h2 id="好多个组合标记"><a href="#好多个组合标记" class="header-anchor">#</a> 好多个组合标记</h2> <p>上面的方法仍然不够完美，因为可能同时有很多个字符组合在一起，而且没有对应的normalize形式，这种时候normalize方法就没用了。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token string">'q\u0307\u0323'</span><span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token string">'NFC'</span><span class="token punctuation">)</span> <span class="token comment">// `q̣̇`</span>
<span class="token string">'q\u0307\u0323'</span>

<span class="token operator">&gt;&gt;</span> <span class="token function">countSymbolsPedantically</span><span class="token punctuation">(</span><span class="token string">'q\u0307\u0323'</span><span class="token punctuation">)</span>
<span class="token number">3</span> <span class="token comment">// not 1</span>

<span class="token operator">&gt;&gt;</span> <span class="token function">countSymbolsPedantically</span><span class="token punctuation">(</span><span class="token string">'Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞'</span><span class="token punctuation">)</span>
<span class="token number">74</span> <span class="token comment">// not 6</span>
</code></pre></div><p>当然你可以用一些鸡贼的方法，比如用正则表达式剔除掉组合字符然后得到正确的结果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Note: replace the following regular expression with its transpiled equivalent</span>
<span class="token comment">// to make it work in old environments. https://mths.be/bwm</span>
<span class="token keyword">var</span> regexSymbolWithCombiningMarks <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\P{Mark})(\p{Mark}+)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gu</span></span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">countSymbolsIgnoringCombiningMarks</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Remove any combining marks, leaving only the symbols they belong to:</span>
  <span class="token keyword">var</span> stripped <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>regexSymbolWithCombiningMarks<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">$0<span class="token punctuation">,</span> symbol<span class="token punctuation">,</span> combiningMarks</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> symbol<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Account for astral symbols / surrogates, just like we did before:</span>
  <span class="token keyword">return</span> punycode<span class="token punctuation">.</span>ucs2<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>stripped<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面这个方法会先剔除那些组合符号，然后再统计符号个数，这个方法甚至对ES3都可以使用，并且提供的结果相当精确。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token function">countSymbolsIgnoringCombiningMarks</span><span class="token punctuation">(</span><span class="token string">'q\u0307\u0323'</span><span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token operator">&gt;&gt;</span> <span class="token function">countSymbolsIgnoringCombiningMarks</span><span class="token punctuation">(</span><span class="token string">'Z͑ͫ̓ͪ̂ͫ̽͏̴̙̤̞͉͚̯̞̠͍A̴̵̜̰͔ͫ͗͢L̠ͨͧͩ͘G̴̻͈͍͔̹̑͗̎̅͛́Ǫ̵̹̻̝̳͂̌̌͘!͖̬̰̙̗̿̋ͥͥ̂ͣ̐́́͜͞'</span><span class="token punctuation">)</span>
<span class="token number">6</span>
</code></pre></div><h2 id="其他类型的符号"><a href="#其他类型的符号" class="header-anchor">#</a> 其他类型的符号</h2> <p>上面介绍的方法仍然过于简单了，因为它对于下面这种不是组合符号但又挤在一起的符号使无能为力，比如நி (ந + ி)，或者깍 (ᄁ + ᅡ + ᆨ)，或者特殊emoji序列比如👨‍👩‍👧‍👦 (👨 + U+200D ZERO WIDTH JOINER + 👩 + U+200D ZERO WIDTH JOINER + 👧 + U+200D ZERO WIDTH JOINER + 👦)，或者其他的情况。。</p> <p>Unicode规范第29号附录“Unicode Text Segmentation”描述了一个判定簇型符号边界的算法。所以，100%精确的解决办法是用Javascript去实现那个算法，然后再统计到底有多少个肉眼可见的字符。ES有一个提案是引入一个叫<code>Intl.Segmenter</code>的方法，来决定文本的分隔符的，可以辅助解决这个问题。</p> <h2 id="在javascript中将字符串反过来"><a href="#在javascript中将字符串反过来" class="header-anchor">#</a> 在Javascript中将字符串反过来</h2> <p>与上面的数字符相比，还有一个类似的问题：反转Javascript的字符串。这有什么难的？最简单的方法是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// naive solution</span>
<span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> string<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大部分情况下看着都没问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span>
<span class="token string">'cba'</span>

<span class="token operator">&gt;&gt;</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">'mañana'</span><span class="token punctuation">)</span> <span class="token comment">// U+00F1</span>
<span class="token string">'anañam'</span>
</code></pre></div><p>但是，如果字符串包含组合标记，或者非BMP符号，就不管用了。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">'mañana'</span><span class="token punctuation">)</span> <span class="token comment">// U+006E + U+0303</span>
<span class="token string">'anãnam'</span> <span class="token comment">// note: the `~` is now applied to the `a` instead of the `n`</span>

<span class="token operator">&gt;&gt;</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">'💩'</span><span class="token punctuation">)</span> <span class="token comment">// U+1F4A9</span>
<span class="token string">'  '</span> <span class="token comment">// `'\uDCA9\uD83D'`, the surrogate pair for `💩` in the wrong order</span>
</code></pre></div><p>为了能正确反转非BMP符号，我们同样可以用ES6引入的字符串迭代器来做。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// slightly better solution that relies on ES6 StringIterator and `Array.from`</span>
<span class="token keyword">function</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不过这个方法对于组合标记还是不行。</p> <p>幸运的是，这个还算好解决，就是在反转之前把所有组合标记多反转一次就好了。有个库可以做这个事情。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// using Esrever (https://mths.be/esrever)</span>

<span class="token operator">&gt;&gt;</span> esrever<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">'mañana'</span><span class="token punctuation">)</span> <span class="token comment">// U+006E + U+0303</span>
<span class="token string">'anañam'</span>

<span class="token operator">&gt;&gt;</span> esrever<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token string">'💩'</span><span class="token punctuation">)</span> <span class="token comment">// U+1F4A9</span>
<span class="token string">'💩'</span> <span class="token comment">// U+1F4A9</span>
</code></pre></div><h2 id="字符串方法中的unicode问题"><a href="#字符串方法中的unicode问题" class="header-anchor">#</a> 字符串方法中的Unicode问题</h2> <p>字符串的某些方法也会收到影响</p> <h3 id="将code-point转换成符号"><a href="#将code-point转换成符号" class="header-anchor">#</a> 将code point转换成符号</h3> <p><code>String.fromCharCode</code>可以让你从Unicode code point直接得到对应的符号。但是这个方法只对BMP符号有效。如果你使用了非BMP符号的code point你会得到错误的结果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span><span class="token number">0x0041</span><span class="token punctuation">)</span> <span class="token comment">// U+0041</span>
<span class="token string">'A'</span> <span class="token comment">// U+0041</span>

<span class="token operator">&gt;&gt;</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span><span class="token number">0x1F4A9</span><span class="token punctuation">)</span> <span class="token comment">// U+1F4A9</span>
<span class="token string">''</span> <span class="token comment">// U+F4A9, not U+1F4A9</span>
</code></pre></div><p>唯一的办法是使用surrogate pairs，但是你得先学会如何从code points计算得到surrogate code point</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span><span class="token number">0xD83D</span><span class="token punctuation">,</span> <span class="token number">0xDCA9</span><span class="token punctuation">)</span>
<span class="token string">'💩'</span> <span class="token comment">// U+1F4A9</span>
</code></pre></div><p>如果你不想自己计算surrogate code point，你可以用punycode.js的<code>encode</code>方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> punycode<span class="token punctuation">.</span>ucs2<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span><span class="token punctuation">[</span> <span class="token number">0x1F4A9</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'💩'</span> <span class="token comment">// U+1F4A9</span>
</code></pre></div><p>幸运的是，ES6引入了一个<code>String.fromCodePoint(codepoint)</code>的方法，这个方法能够正确处理所有Unicode字符。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> String<span class="token punctuation">.</span><span class="token function">fromCodePoint</span><span class="token punctuation">(</span><span class="token number">0x1F4A9</span><span class="token punctuation">)</span>
<span class="token string">'💩'</span> <span class="token comment">// U+1F4A9</span>
</code></pre></div><p>如果是ES5或者更老的版本，可以使用String.fromCodePoint的polyfill。</p> <h3 id="从字符串中扣取字符"><a href="#从字符串中扣取字符" class="header-anchor">#</a> 从字符串中扣取字符</h3> <p>如果你使用<code>String.prototype.charAt(position)</code>来从一个字符串中扣取一个非BMP字符，那么你得到的是半个surrogate pair。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token string">'💩'</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// U+1F4A9</span>
<span class="token string">'\uD83D'</span> <span class="token comment">// U+D83D, i.e. the first surrogate half for U+1F4A9</span>
</code></pre></div><p>ES7有一个提案是希望引入一个新方法<code>String.prototype.at(position)</code>来解决这个问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token string">'💩'</span><span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// U+1F4A9</span>
<span class="token string">'💩'</span> <span class="token comment">// U+1F4A9</span>
</code></pre></div><p>同样的，也有对应的polyfill可用。</p> <h3 id="从字符串中扣取code-point"><a href="#从字符串中扣取code-point" class="header-anchor">#</a> 从字符串中扣取code point</h3> <p>同样的，如果你用<code>String.prototype.charCodeAt(position)</code>想扣取指定位置的code point，对于非BMP符号，你只会得到半个surrogate pair。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token string">'💩'</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">0xD83D</span>
</code></pre></div><p>ES6提供了一个方法<code>String.prototype.codePointAt(position)</code>可以解决这个问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token string">'💩'</span><span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">0x1F4A9</span>
</code></pre></div><p>同样的，也有polyfill可以用。</p> <h3 id="遍历字符串中的所有符号"><a href="#遍历字符串中的所有符号" class="header-anchor">#</a> 遍历字符串中的所有符号</h3> <p>假设你要遍历字符串中的所有符号，在ES5中，你需要写一大堆代码才能实现正确的逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getSymbols</span><span class="token punctuation">(</span><span class="token parameter">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> length <span class="token operator">=</span> string<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword">var</span> output <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> charCode <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>charCode <span class="token operator">&gt;=</span> <span class="token number">0xD800</span> <span class="token operator">&amp;&amp;</span> charCode <span class="token operator">&lt;=</span> <span class="token number">0xDBFF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      charCode <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>charCode <span class="token operator">&gt;=</span> <span class="token number">0xDC00</span> <span class="token operator">&amp;&amp;</span> charCode <span class="token operator">&lt;=</span> <span class="token number">0xDFFF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        output<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>index<span class="token punctuation">;</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    output<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> symbols <span class="token operator">=</span> <span class="token function">getSymbols</span><span class="token punctuation">(</span><span class="token string">'💩'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
symbols<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">symbol</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>symbol <span class="token operator">==</span> <span class="token string">'💩'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>或者你可以用正则表达式，比如<code>var regexCodePoint = /[^\uD800-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDFFF]/g;</code>来做类似的事情。</p> <p>在ES6中，直接用for of迭代器就可以了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> symbol <span class="token keyword">of</span> <span class="token string">'💩'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>symbol <span class="token operator">==</span> <span class="token string">'💩'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不过for of是没有polyfill的，因为这是个语法层面的新功能。</p> <h3 id="其他问题"><a href="#其他问题" class="header-anchor">#</a> 其他问题</h3> <p>其实几乎所有String的方法都会受到影响，比如（String.prototype.substring，String.prototype.slice等等），所以使用他们的时候要小心。</p> <h2 id="unicode对正则表达式的影响"><a href="#unicode对正则表达式的影响" class="header-anchor">#</a> Unicode对正则表达式的影响</h2> <h3 id="匹配code-point和unicode符号"><a href="#匹配code-point和unicode符号" class="header-anchor">#</a> 匹配code point和Unicode符号</h3> <p>在正则表达式中，<code>.</code>代表一个单个的符号，但是因为javascript是用surrogate pairs来表示非BMP的，而正则表达式会认为这是两个字符。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">foo.bar</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo💩bar'</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>
</code></pre></div><p>让我们停下来仔细思考一下，怎么样让正则表达式匹配非BMP符号呢？显然<code>.</code>是不行的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^.$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'💩'</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>
</code></pre></div><p>一种办法是直接手写出code points空间，虽然看上去不是那么直观：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'💩'</span><span class="token punctuation">)</span> <span class="token comment">// wtf</span>
<span class="token boolean">true</span>
</code></pre></div><p>当然通常你不需要手写这些东西，因为会有一些现成的第三方库帮你做这个事情，比如regenerate，它能够根据code point或符号生成对应的正则。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token function">regenerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addRange</span><span class="token punctuation">(</span><span class="token number">0x0</span><span class="token punctuation">,</span> <span class="token number">0x10FFFF</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]'</span>
</code></pre></div><p>生成的正则从左到右依次匹配了BMP符号，surroage pairs，long surrogates。至于long surrogate是个什么东西，这里就不作展开了。</p> <p>ES6引入了一个u标记，用来解决上面所述的正则匹配的<code>.</code>问题：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">foo.bar</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo💩bar'</span><span class="token punctuation">)</span>
<span class="token boolean">false</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">foo.bar</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'foo💩bar'</span><span class="token punctuation">)</span>
<span class="token boolean">true</span>
</code></pre></div><h3 id="非bmp符号的分类"><a href="#非bmp符号的分类" class="header-anchor">#</a> 非BMP符号的分类</h3> <p>比如像<code>/[a-c]/</code>这样的正则，我们知道是从U+0061 LATIN SMALL LETTER A 到 U+0063 LATIN SMALL LETTER C。如果是<code>/[💩-💫]/</code>，看上去就是从U+1F4A9 PILE OF POO 到 U+1F4AB DIZZY SYMBOL，但实际并不是这样。</p> <div class="language- extra-class"><pre class="language-text"><code>&gt;&gt; /[💩-💫]/
SyntaxError: Invalid regular expression: Range out of order in character class
</code></pre></div><p>这是因为上面的正则等价于下面这样</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\uD83D\uDCA9-\uD83D\uDCAB]</span><span class="token regex-delimiter">/</span></span>
<span class="token literal-property property">SyntaxError</span><span class="token operator">:</span> Invalid regular expression<span class="token operator">:</span> Range out <span class="token keyword">of</span> order <span class="token keyword">in</span> character <span class="token keyword">class</span>
</code></pre></div><p>又是surrogate pairs，所以实际上这个正则匹配的是三段，而中间那一段\uDCA9-\uD83D是非法的，因为起始编码大于了结束编码。</p> <p>ES6再一次拯救了我们，通过u标记可以解决这个问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\uD83D\uDCA9-\uD83D\uDCAB]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'\uD83D\uDCA9'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4A9</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\u{1F4A9}-\u{1F4AB}]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'\u{1F4A9}'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4A9</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[💩-💫]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'💩'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4A9</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\uD83D\uDCA9-\uD83D\uDCAB]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'\uD83D\uDCAA'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4AA</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\u{1F4A9}-\u{1F4AB}]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'\u{1F4AA}'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4AA</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[💩-💫]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'💪'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4AA</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\uD83D\uDCA9-\uD83D\uDCAB]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'\uD83D\uDCAB'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4AB</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[\u{1F4A9}-\u{1F4AB}]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'\u{1F4AB}'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4AB</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[💩-💫]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">u</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'💫'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4AB</span>
<span class="token boolean">true</span>
</code></pre></div><p>不幸的是，这个方法无法兼容ES5和更老的环境，如果你真的有需要，建议使用regenerate这个工具库生成正确的正则表达式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&gt;&gt;</span> <span class="token function">regenerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addRange</span><span class="token punctuation">(</span><span class="token string">'💩'</span><span class="token punctuation">,</span> <span class="token string">'💫'</span><span class="token punctuation">)</span>
<span class="token string">'\uD83D[\uDCA9-\uDCAB]'</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\uD83D[\uDCA9-\uDCAB]$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'💩'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4A9</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\uD83D[\uDCA9-\uDCAB]$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'💪'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4AA</span>
<span class="token boolean">true</span>

<span class="token operator">&gt;&gt;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\uD83D[\uDCA9-\uDCAB]$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'💫'</span><span class="token punctuation">)</span> <span class="token comment">// match U+1F4AB</span>
<span class="token boolean">true</span>
</code></pre></div><h2 id="生产环境中的bug以及如何避免"><a href="#生产环境中的bug以及如何避免" class="header-anchor">#</a> 生产环境中的bug以及如何避免</h2> <p>举一个实际的例子，twitter的每一个tweet只允许140个字符，而后端可不管这是什么字符，BMP还是非BMP。但是因为Javascript在前端是仅仅通过<code>length</code>方法判断长度，所以如果你输入的都是非BMP字符，那最多只能打70个。（这个bug现在已经被修复了）</p> <p>许多javascript的库都没能正确处理非BMP字符。比如countable.js,underscore.js等等。有时候html中包含一些特殊的数字也可能导致html解码失败，比如&amp;#X1F4A9。这里推荐he这个库做html的编解码。</p> <p>以上这些都是比较容易产生和修复的错误，毕竟Javascript处理Unicode是很麻烦的。那么除了修复的办法，怎么发现这些错误呢？</p> <h2 id="the-pile-of-poo-test"><a href="#the-pile-of-poo-test" class="header-anchor">#</a> The Pile of Poo Test</h2> <p>无论何时当你编写需要处理字符串或正则表达式的代码时，记得在UT的字符串里添加一个翔（💩），然后看看是否正常。这个方法很方便，很管用，也很有趣，能帮助你检查你的代码是否正确处理了非BMP字符。如果你发现了错误，你就可以使用上面介绍的方法修复了。</p> <p>更完善的Unicode字符串是<code>Iñtërnâtiônàlizætiøn☃💩</code>，这20个字符包含了从U+0100到U+FFFF的BMP字符，以及从U+010000到U+10FFF的非BMP字符。</p></div></div> <div class="comment" data-v-63da4bd6><Vssue data-v-63da4bd6></Vssue></div></div></div> <div class="container" data-v-07c4fbe2 data-v-ad494eec>
  Designed by <a href="/about" data-v-07c4fbe2>Lishunyang</a> | <a href="https://beian.miit.gov.cn/" target="_blank" data-v-07c4fbe2>京ICP备20009157号</a> | All right reserved
</div></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.a48c4f56.js" defer></script><script src="/blog/assets/js/2.e0432708.js" defer></script><script src="/blog/assets/js/36.920da182.js" defer></script>
  </body>
</html>
