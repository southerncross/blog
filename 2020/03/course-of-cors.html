<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>有关CORS的一课 | Lishunyang&#39;s Blog</title>
    <meta name="description" content="Lishunyang&#39;s Blog">
    <link rel="icon" type="image/png" href="/blog/favicon.png">
  <meta name="keywords" content="Javascript,HTTP,Nodejs,React">
    
    <link rel="preload" href="/blog/assets/css/0.styles.9d0cb107.css" as="style"><link rel="preload" href="/blog/assets/js/app.c8d67ad9.js" as="script"><link rel="preload" href="/blog/assets/js/3.acd1c8f7.js" as="script"><link rel="preload" href="/blog/assets/js/11.8a356812.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.9d0cb107.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-v-ad494eec><ul class="container" data-v-37370f15 data-v-ad494eec><li class="title" data-v-37370f15><a href="/blog/" data-v-37370f15><img src="/blog/assets/img/avatar.cf743a85.jpg" class="avatar" data-v-37370f15>Lishunyang's Blog</a></li> <li class="item" data-v-37370f15><a href="/blog/about.html" data-v-37370f15>About</a></li></ul> <div class="main" data-v-ad494eec><div class="container" data-v-63da4bd6 data-v-ad494eec><div class="header" data-v-63da4bd6><h1 class="title" data-v-63da4bd6>有关CORS的一课</h1> <div class="date-and-tags" data-v-63da4bd6><span class="date" data-v-63da4bd6>2020/3/12</span> <!----></div></div> <ul class="sidebar" data-v-63da4bd6><li class="sidebar-item" data-v-63da4bd6><a href="/2020/03/course-of-cors.html#为什么跨域xhr是被禁止的" data-v-63da4bd6>为什么跨域xhr是被禁止的</a></li></ul> <div class="content" data-v-63da4bd6><div class="content__default" data-v-63da4bd6><p>今天晚上跟团队里的小伙伴一起调查了一个非常诡异的问题，整个过程把CORS又重新梳理了一遍，正所谓“纸上得来终觉浅，绝知此事要躬行”，通过这一次调查，让我对CORS的理解一下子深刻了许多。</p> <p>问题是这样的：有个功能需要在浏览器环境调用高德地图WebAPI（一个简单的GET请求），结果测试的时候发现，有的页面请求正常，有的页面请求竟然会报跨域错误。</p> <p>这是什么道理 😅</p> <h1 id="跨域是什么"><a href="#跨域是什么" class="header-anchor">#</a> 跨域是什么</h1> <p>让我们先来回忆一下跨域是什么。</p> <p>所谓<code>跨域</code>，自然是针对<code>同域</code>来讲的，而<code>同域</code>这个概念出自浏览器的<a href="https://www.w3.org/Security/wiki/Same_Origin_Policy" target="_blank" rel="noopener noreferrer"><code>同源策略</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。注意了，只有浏览器环境才有同源策略，也就是只有浏览器环境才有跨域的情况，非浏览器环境发HTTP请求是不会遇到跨域的问题的。因此有些小伙伴尝试用curl或者postman等工具验证跨域问题多半是不会得到正确结果的，因为这种情况下就不存在跨域问题。</p> <p>那么浏览器又是如何处理跨域请求的呢？假设现在我们在浏览器环境中尝试发送一个跨域请求，这个请求是会被浏览器截胡呢还是真的发出去呢？</p> <p>这里不妨让做个实验，本地起一个http server：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'X-lishunyang'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在就在这个博客里，打开控制台，输入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://localhost:8848/'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'GET'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>然后观察chrome的network面板，结果发现，请求不仅发出了而且也返回了，因为我们看到response里包含了我们设置的自定义header（红框内容），只不过response的body是空的（虽然server端的确返回了东西）。</p> <p><img src="/blog/assets/img/corss_domain_test.28c9c871.png" alt="cross domain test"></p> <p>所以即便是个跨域请求，chrome也会正常发出和收到响应，只不过chrome将response的body部分隐藏了起来，并且在代码中抛出异常，告诉你请求有跨域问题，请求失败了。</p> <blockquote><p>这种实际上发出了但是被浏览器隐藏了响应体的请求，有一个名字叫“透明请求”（opaque request）。</p></blockquote> <p>同样的动作，如果在firefox下，请求是发不出去的，而在edge下又是可以的。不同浏览器的行为不一致。</p> <p>查询W3C的同源策略规范可以知道，同源策略其实不限制请求的发出，只是限制了获取响应数据。但我认为firefox的处理逻辑其实更好，因为更加安全。比如某个请求不需要响应体只要响应头就行了，甚至连响应都不行要，只要把请求发出去就行了，这种情况下，chrome和edge的同源策略会失去作用。</p> <h2 id="为什么跨域xhr是被禁止的"><a href="#为什么跨域xhr是被禁止的" class="header-anchor">#</a> 为什么跨域xhr是被禁止的</h2> <p>为什么跨域请求是被禁止的呢？我们知道在浏览器环境中a、img、script、link、iframe等标签发出的GET请求是不受同源策略影响的，甚至form表单发出的POST请求都是不受同源策略影响的，既然有这么多请求都是可以跨域的，为什么浏览器偏偏要限制跨域的xhr呢？</p> <p>关于这个问题，我个人的理解是：xhr是由js发出而不是html标签发出，这意味着xhr的行为更加灵活（GET、PUT、POST、DELETE），携带的数据更加不可控（自定义header和body），更容易构造出恶意请求。比如CSRF攻击，因为有了同源策略的限制，只能是通过html标签的形式触发（否则也就不叫CSRF了，直接叫RF就行了）。</p> <h1 id="cors"><a href="#cors" class="header-anchor">#</a> CORS</h1> <p>跨域与翻墙不同，跨域其实是一种常见的业务需要，尤其是那些第三方开放web API（比如前面提到的高德地图），只要允许在浏览器环境下调用，那几乎全都是跨域请求。正因为如此，才会有CORS（Cross-Origin Resource Sharing），它是W3C所规定的合法跨域方式（<a href="https://www.w3.org/TR/cors/" target="_blank" rel="noopener noreferrer">规范见这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），所有浏览器和http server都会遵守，它到底有多重要？看看Mozilla MDN的说法：</p> <p><img src="/blog/assets/img/who_should_read_this.486c28c4.png" alt="who should read this"></p> <p>记住下面三个概念对于理解CORS很有帮助：</p> <ol><li>首先，是不是跨域，浏览器说了算。</li> <li>其次，能不能跨域，服务器说了算。</li> <li>最终，要不要跨域，浏览器说了算。</li></ol> <h1 id="简单请求跨域"><a href="#简单请求跨域" class="header-anchor">#</a> 简单请求跨域</h1> <p>回到最开始的例子，如果想在当前博客域名下向localhost的http服务器正常发送GET xhr请求，怎么做呢？</p> <p>显然是跨域了，允不允许跨域是由服务器说了算的。</p> <p>这时我们只需要在服务器返回的响应头部加入一个header：<code>access-controll-allow-origin: *</code>即可。这个header的含义已经非常明确了，就是允许请求从任何域名发起。我们稍微修改一下之前的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'X-lishunyang'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'access-control-allow-origin'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意这里</span>
  res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在再从浏览器中发起请求<code>fetch('http://localhost:8848')</code>，可以看到请求成功返回，跨域解决了。</p> <p><img src="data:image/png;base64,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" alt="simple request"></p> <p>这里的<code>access-control-allow-origin</code>头部，就是允许来自哪些域名的请求跨域。除了*之外，还可以配置具体的源（origin），比如<code>http://localhost:8848</code>。</p> <p>注意这里allow的是origin，根据同源策略的规定，origin是由<code>schema</code>，<code>domain</code>，<code>port</code>三部分组成。</p> <p>比如我们可以将access-control-allow-origin改为<code>https://blog.lishunyang.com</code>。</p> <p>哪些请求算是简单请求呢？简单来说就是：</p> <ol><li>只能是简单方法，比如GET、HEAD、POST</li> <li>只能设置简单头部，比如Accept、Accept-Language、Cotnent-Language或者值是application/x-www-form-urlencoded、multipart/form-data、text/plain之一的Content-Type。</li></ol> <p>注意，第2点需要额外再说明一下，并不是说简单请求只能带有上述几个header，这里的意思是说，如果你想手动设置请求的header，那只能设置这几种。浏览器自动帮你设置的header不受这个限制。举个例子，浏览器自动帮你给request上添加了cookie这个header，仍然算是简单请求。</p> <p>除了简单请求之外都算是复杂请求。请记住上面这两个条件，复杂请求的处理其实也就是围绕着这两个东西的处理。</p> <h1 id="复杂请求跨域"><a href="#复杂请求跨域" class="header-anchor">#</a> 复杂请求跨域</h1> <p>如果是复杂请求，情况自然也会复杂一点。此时浏览器会非常谨慎，服务器需要返回更多的信息告诉浏览器到底能不能跨域。</p> <p>首先，浏览器会在正式请求发起之前先发送一个OPTIONS请求，用来先向服务器打探一下情况。这个OPTIONS请求被叫做预检请求（preflight request）。这个预检请求是浏览器自动发送的，无需开发者手动控制。</p> <p>比如我们向local发起一个PUT请求：<code>fetch('http://localhost:8848', { method: 'PUT' })</code>，此时将看到浏览器报预检请求错误：</p> <p><img src="/blog/assets/img/preflight_error.18cc20cc.png" alt="preflight error"></p> <p>由于浏览器不会显示失败的OPTIONS请求的信息，所以我们可以在后端log出请求，可以看到这是个OPTIONS请求，且有一个<code>access-control-request-method: PUT</code>的header以及一个<code>origin: xxxx</code>的header。</p> <p><img src="/blog/assets/img/cors_options.0f820dc4.png" alt="options"></p> <p>对了，上面的例子展示的是我们发出一个非简单方法的请求，如果我们发出的请求还带有非简单头部，那么OPTIONS请求也会响应带上<code>access-control-request-header</code>。</p> <p>服务器端收到预检请求后，可以根据origin、request-method、request-header三个信息决定是否允许浏览器跨域，如果允许则服务器必须在OPTIONS的响应头部包含<code>access-control-allow-methods</code>或者<code>access-control-allow-headers</code>。比如我们可以把server端代码改一下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'X-lishunyang'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'access-control-allow-origin'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'access-control-allow-methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意这里</span>
  res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果每次复杂请求都要发预检请求，那岂不是太傻了，所以服务端还可以在OPTIONS的header里增加<code>access-control-max-age</code>，告诉浏览器在一定缓存时间内就不用再发预检请求了。</p> <p>此外，服务器还可以通过<code>access-control-expose-headers</code>来告诉浏览器，允许哪些header被展示，哪些header不被展示。不过经过本人测试，这个似乎没用。</p> <h1 id="带有credential的请求"><a href="#带有credential的请求" class="header-anchor">#</a> 带有credential的请求</h1> <p>credential指的是用户认证相关的信息，比如cookie、auth header、tls证书等等。为了保证安全，浏览器默认是不会在跨域请求中包含credential信息的。因此你会发现前面的例子里，所有跨域请求的header里都没有cookie。</p> <p>其实浏览器是支持开发者手动控制是否发送credentials的，比如<code>fetch('http://localhost:8848', { credendials: 'include' })</code>，让我们测试看看，等一下，怎么报错了？</p> <p><img src="/blog/assets/img/credentials_error.63c2ed25.png" alt="credentials error"></p> <p>观察错误信息，原来如果请求里带有了credentials信息，<code>access-control-allow-origin</code>就不能为*，仍然是出于安全考虑！所以让我们再次修改后端代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'X-lishunyang'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'access-control-allow-origin'</span><span class="token punctuation">,</span> <span class="token string">'https://blog.lishunyang.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 注意这里</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'access-control-allow-methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>再次尝试，等等，怎么还有报错？</p> <p><img src="/blog/assets/img/with_credentials_error_2.001aac58.png" alt="again, error"></p> <p>仔细观察错误信息，原来如果请求中带有credentials信息，server端必须返回<code>access-control-allow-credentials: true</code>才行。让我们再次修改后端代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'X-lishunyang'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'access-control-allow-origin'</span><span class="token punctuation">,</span> <span class="token string">'https://blog.lishunyang.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'access-control-allow-methods'</span><span class="token punctuation">,</span> <span class="token string">'PUT'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'access-control-allow-credentials'</span><span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意这里</span>
  res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在测试一下，总算是可以了，总结一下就是，如果请求中带有credentials，那么CORS有一个特殊的规则：</p> <ol><li>响应头部的access-control-allow-origin不能是*</li> <li>响应头部需要额外包含<code>access-control-allow-credentials: true</code></li></ol> <h1 id="cors与csp的区别"><a href="#cors与csp的区别" class="header-anchor">#</a> CORS与CSP的区别</h1> <p>你也许听说过“内容安全策略”，即：Content Security Policy，简称CSP。例如某些站点的响应里可能包含这样的头部：</p> <div class="language- extra-class"><pre class="language-text"><code>content-security-policy: default-src 'self'
</code></pre></div><p>表示当前页面中的资源必须来自相同的origin。有关CSP的概念，这里不做详细展开，如果你不太清楚，可以看<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="noopener noreferrer">这个MDN文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>虽然CSP通常也有一定的阻止跨域的功能，但其实CSP侧重的是控制资源的来源，换句话说也就是<strong>控制GET请求的来源</strong>，这主要是为了阻止引入未知来源的资源，防止XSS攻击。而且<strong>CSP会对页面中的所有GET请求生效</strong>，不论是XHR还是a、img、script等html标签。这两点是CSP与CORS最大的区别。</p> <p>另外，CSP和CORS二者是独立的，比如一个跨域的GET请求，既要通过CSP的检查，也要通过CORS的检查。</p> <h1 id="回到最初的问题"><a href="#回到最初的问题" class="header-anchor">#</a> 回到最初的问题</h1> <p>回到当初那个调用高德地图Web API请求跨域的问题，一个简单的GET调用报跨域的蜜汁问题。</p> <p>因为这是个第三方开放API，access-allow-origin肯定是*，此时却出现了跨域，会不会是GET请求带上了credential信息呢（比如cookie）？</p> <p>结果抓包发现请求并没有带cookie，这就非常迷惑了。后来团队中的另一个同学注意到抓包捕获到的请求是一个OPTIONS请求而不是GET请求。这说明这个GET请求被判定为是非简单请求，那么一定是人工设置了非简单头部。仔细检查发现，请求里确实多了一个<code>x-csrf-token</code>的头部，经过调查得知是原来是因为前两天团队的其他同学修复CSRF安全漏洞给xhr请求都添加了这个头部，而查看代码发现，这个注入逻辑只在某些页面生效，于是一切都解释的通了。</p> <p>最后的解决办法就是，将高德地图API加入了白名单，此时不添加x-csrf-token，果然问题解决了。</p> <p>最后，我在浏览器中尝试复现这个问题的时候发现，其实fetch给出的提示已经很清楚了：</p> <p><img src="/blog/assets/img/x_csrf_token_not_allowed.aed91011.png" alt="not allowed header"></p> <p>然而碰巧我们的代码里的请求是使用了一个叫superagent的库发出的，它会把这个错误拦截掉，然后统一抛出一个非常general的CORS错误，害的我们调查半天。。</p> <h1 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h1> <ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank" rel="noopener noreferrer">W3C: CORS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <div class="comment" data-v-63da4bd6><!----></div></div></div> <div class="container" data-v-07c4fbe2 data-v-ad494eec>
  Designed by <a href="/about" data-v-07c4fbe2>Lishunyang</a> | <a href="https://beian.miit.gov.cn/" target="_blank" data-v-07c4fbe2>京ICP备20009157号</a> | All right reserved
</div></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.c8d67ad9.js" defer></script><script src="/blog/assets/js/3.acd1c8f7.js" defer></script><script src="/blog/assets/js/11.8a356812.js" defer></script>
  </body>
</html>
