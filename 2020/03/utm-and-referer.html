<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>referer和utm | Lishunyang&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" type="image/png" href="/blog/favicon.png">
    <meta name="description" content="Lishunyang&#39;s Blog">
    <meta name="keywords" content="Javascript,HTTP,Nodejs,React">
    
    <link rel="preload" href="/blog/assets/css/0.styles.102d8b8d.css" as="style"><link rel="preload" href="/blog/assets/js/app.a48c4f56.js" as="script"><link rel="preload" href="/blog/assets/js/2.e0432708.js" as="script"><link rel="preload" href="/blog/assets/js/28.3aaeec56.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.102d8b8d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-v-ad494eec><ul class="container" data-v-26d88251 data-v-ad494eec><li class="title" data-v-26d88251><a href="/blog/" data-v-26d88251><img src="/blog/assets/img/avatar.cf743a85.jpg" class="avatar" data-v-26d88251>Lishunyang's Blog</a></li> <li class="item" data-v-26d88251><a href="/about.html" data-v-26d88251>About</a></li></ul> <div class="main" data-v-ad494eec><div class="container" data-v-63da4bd6 data-v-ad494eec><div class="header" data-v-63da4bd6><h1 class="title" data-v-63da4bd6>referer和utm</h1> <div class="date-and-tags" data-v-63da4bd6><span class="date" data-v-63da4bd6>2020/3/7</span> <!----></div></div> <!----> <div class="content" data-v-63da4bd6><div class="content__default" data-v-63da4bd6><p>对于网站的运营人员来说，流量来源分析是一个非常重要的工作。你一定很关心用户到底是从什么地方来的，是通过搜索引擎主动搜索进入的？还是通过点击微信朋友圈转发的文章链接进入的？还是通过某个广告推广链接进入的？</p> <h1 id="referer"><a href="#referer" class="header-anchor">#</a> referer</h1> <p>说到来源分析，那么自然要提到HTTP的一个header：<code>referer</code>。</p> <p>根据规范，referer记录的是当前请求是从哪个页面发起的，比如当你在某个页面中点击一个a标签时，可以看到发出的HTTP请求头部就带有当前页面的url信息。</p> <p><img src="/blog/assets/img/http_referer.8ca89bea.png" alt="http referer"></p> <p>referer是由user agent（也就是浏览器）在发起HTTP请求时自动加上的，而且几乎所有浏览器发起的HTTP请求头里都带有这个header，甚至是在浏览器的隐私模式下也是有referer的。</p> <p>当然如果你是直接在地址栏输入一个url打开一个页面，那么这个url的GET请求是没有referer的，不过还有一些其他情况会导致没有referer，后面会详细讲到。</p> <p>现在有一个小问题考考你，看你对referer的理解，假设在<code>http://example.com/</code>下有如下a链接：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>http://example.com/1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>click<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>访问这个链接server端会返回一个301跳转，Location为<code>http://example.com/2</code>，那么最终向<code>http://example.com/2</code>发出请求的referer会是什么呢？是<code>http://example.com/</code>还是<code>http://example.com/1</code>呢？</p> <p>分析整个流程可知，即使经过了301跳转，最后的请求仍然是在<code>http://example.com/</code>发出的，所以referer自然是<code>http://example.com</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>http://example.com/               server
         |             /1            |
         |--------------------------&gt;|
         |                           |
         |         301 to /2         |
         |&lt;--------------------------|
         |                           |
         |             /2            |
         |--------------------------&gt;|
</code></pre></div><p>你可以通过javascript的<code>document.referer</code>在前端获取到当前页面的referer信息。</p> <h1 id="referer的用途"><a href="#referer的用途" class="header-anchor">#</a> referer的用途</h1> <p>referer被发明出来的目的就是做流量来源分析，实际上它可以做很多事情。</p> <ol><li>流量分析</li></ol> <p>这个就不多说了，本职工作</p> <ol start="2"><li>图片防盗链、音视频防下载</li></ol> <p>后端服务器检查图片、音视频资源的HTTP请求的referer，如果与站点url不同域，说明请求来自其他站点，此时返回一个错误信息。</p> <ol start="3"><li>防止CSRF攻击</li></ol> <p>CSRF攻击是诱导用户去点击恶意构造的链接，借用户的手进行一些操作，这种链接通常来自一些钓鱼页面，发出的请求也自然带有钓鱼页面的referer（或者没有referer），服务端可以通过检测referer来发现和组织非法的请求。</p> <ol start="4"><li>实现“后退”功能</li></ol> <p><code>history.back()</code>的一个局限性是历史记录仅对当前页面session有效，如果页面跳转到一个新窗口，那么在新窗口里是无法用<code>history.back()</code>回去的，那么此时就可以用referer实现后退功能了。</p> <h1 id="伪造referer"><a href="#伪造referer" class="header-anchor">#</a> 伪造referer</h1> <p>因为referer是客户端决定的，所以从服务器的角度看，referer的真实性是不可靠的。比如你可以用curl命令添加referer：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># -e 代表设置referer，-v打印header</span>
<span class="token function">curl</span> https://www.baidu.com <span class="token parameter variable">-e</span> https://blog.lisunyang.com <span class="token parameter variable">-v</span>
</code></pre></div><p>可以看到referer已经被设置成<code>https://blog.lishunyang.com</code>了:</p> <div class="language- extra-class"><pre class="language-text"><code>&gt; GET / HTTP/1.1
&gt; Host: www.baidu.com
&gt; User-Agent: curl/7.58.0
&gt; Accept: */*
&gt; Referer: https://blog.lisunyang.com
</code></pre></div><p>所以对于后端爬虫来说，referer的限制通通都是失效的。</p> <p>看到这里你也许会思考：在前端构造ajax请求的时候也指定referer，岂不是可以为所欲为了？很可惜，浏览器早就料到了有人会这么干，所以所有请求在发出的时候，浏览器会按照正常规则覆盖referer头部。所以这种方式是不可行的。</p> <h1 id="referrer-policy"><a href="#referrer-policy" class="header-anchor">#</a> Referrer-Policy</h1> <blockquote><p>Referrer Policy这里的Referrer其实是一个错误的拼写，但用得太多，所以被沿用下来了。。</p></blockquote> <p>referer主要的安全风险是信息泄露，当url包含有一些敏感信息时，这些敏感信息就可能会随着referer被泄露到外部。</p> <p>比如我们在重置密码的时候，通常是通过<a href="https://www.jianshu.com/p/8f7009456abc" target="_blank" rel="noopener noreferrer">bearer token<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>进行身份验证的，此时token是放在url中的：</p> <div class="language- extra-class"><pre class="language-text"><code>https://example.com/reset_password?access_token=65c36cfa-c1a9-44dd-bbe4-797571a1a341
</code></pre></div><p>当我们打开这个页面时，后续所有请求的referer都会带上这个url。万一这个token不是一次性的而是在一定时间内有效，那这个就很可能造成安全风险。</p> <p>于是W3C引入了Referrer-Policy的规范，用来指导客户端如何发送referer。可能的值有：</p> <ol><li>no-referer</li> <li>no-referer-when-downgrade（默认值，当HTTPS跳转到HTTP时不带referer）</li> <li>same-origin</li> <li>origin</li> <li>strict-origin</li> <li>origin-when-cross-origin</li> <li>strict-origin-when-cross-origin</li> <li>unsafe-url</li> <li>empty</li></ol> <p>具体的含义和细节这里就不罗嗦了，网上的资料到处都是。</p> <blockquote><p>说句题外话，你有没有注意到这个规范是W3C组织确定的？W3C和IETF（RFC）的区别在<a href="https://softwareengineering.stackexchange.com/questions/109517/how-is-ietf-different-from-w3c" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>怎么使用呢？有以下几种使用方式：</p> <ol><li><p>作为HTTP头部引入
例如：<code>Referrer-Policy: no-referrer</code></p></li> <li><p>由html的meta标签引入
例如：<code>&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;&gt;</code></p></li> <li><p>作为html标签的refererpolicy属性引入，可以用在a、area、img、iframe、link标签
例如：<code>&lt;a href=&quot;http://example.com&quot; referrerpolicy=&quot;origin&quot;&gt;</code></p></li> <li><p>从context中继承
例如：iframe的Referrer-Policy继承自浏览器context或blog URL</p></li></ol> <p>再具体的细节就不多讲了。</p> <h1 id="referer就够了吗"><a href="#referer就够了吗" class="header-anchor">#</a> referer就够了吗？</h1> <p>现在再说回流量来源分析。有了referer，我们就可以做来源分析了，但referer还是有一些小缺点。比如：</p> <ol><li>首次打开链接没有referer，这种场景的来源信息无法通过referer获取，比如打开邮件中的链接。</li> <li>referer只能统计从网站外部“进入”网站的行为，而网站内部的跳转行为是无法通过referer进行统计的。比如从A渠道进来的用户会在网站内多次点击，B渠道来的用户进入网站后立刻就走了，这个信息无法用referer分辨。</li> <li>referer会受Referrer-Policy的影响，容易丢失。</li></ol> <p>怎么办呢？于是就有了UTM参数。</p> <h1 id="utm参数"><a href="#utm参数" class="header-anchor">#</a> UTM参数</h1> <p>有时候你会看到一些url的query部分带有utm_开头的部分，例如：</p> <div class="language- extra-class"><pre class="language-text"><code>https://www.example.com/page?utm_source=facebook.com
</code></pre></div><p>url里面的utm_source、utm_campaign等utm_开头的部分，就叫做UTM参数（UTM Parameters），首先申明，UTM参数不是必须的。</p> <p>UTM的缩写是Urchin Tracking Module，这个名字来源自一个叫Urchin的公司，他们最早开始使用这种技术进行来源分析，后来Urchin公司被Google收购，但UTM这个名字渐渐普及并被沿用了下来。主流的流量分析工具服务都可以识别UTM参数，比如Google Ananysis、GrowingIO等等。</p> <p>比较常用的有以下几种</p> <ol><li>utm_source：表示流量来源，比如是搜索引擎、渠道名或者什么来源</li> <li>utm_medium：表示这个链接的媒介，比如是banner图，还是文本链接</li> <li>utm_campaign：广告名称，比如这次活动的名字是什么</li> <li>utm_term：关键字</li></ol> <p>如你所见，utm参数就是作为url的query存在，而且utm参数是人为设定的。比如我在百度上购买了广告，投放的链接地址是<code>https://blog.lishunyang.com/?utm_source=baidu</code>，那么当用户通过点击这个链接进入，GoogleAnalysis就可以帮我统计出这是来自于百度搜索引擎的流量。</p> <p>让我们看看utm参数如何解决之前所说的referer的问题：</p> <ol><li>首次打开链接不受影响，<strong>因为UTM参数是在url上的</strong></li> <li>站点内跳转也可以保留来源信息，<strong>因为UTM参数是在url上的</strong></li> <li>不受Referer-Policy影响，<strong>因为UTM参数是在url上的</strong></li></ol> <p>太棒了，简直完美，但别高兴太早，UTM参数最大的问题也同样是因为<strong>因为UTM参数是在url上的</strong>，准确地说是存在于url的query部分，而url的query是很容易丢失的。比如下面两个链接，点击第一个链接UTM就丢失了，只能按第二种写法写。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/info<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/info?utm_source=baidu<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>info<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这对web开发来讲是一个非常严峻的考验，你必须小心翼翼地构造每一个可能的链接，以确保query能够始终保持。这不是一个很稳妥的做法。所以有些人也会把UTM参数放在cookie中或者LocalStorage以便持久保存，但这又引入了cookie和LocalStorage何时失效的问题。比如当我跳转到一个不带UTM参数的链接时，我到底是应该使用cookie里的UTM信息呢？还是应该认为cookie里的UTM已经失效了，本次链接确实没有UTM参数？</p> <h1 id="utm参数的维护"><a href="#utm参数的维护" class="header-anchor">#</a> UTM参数的维护</h1> <p>碰巧前一段时间在帮市场部开发页面的时候就遇到了这个问题（这也正是这篇博客的由来），市场部的同事总是抱怨新开发的官网活动页经常性会丢失<code>utm_source</code>，因为开发人员在写页面的时候忘记处理这个事情，新写的跳转地址很容易就把query搞丢了。</p> <p>怎么办呢？</p> <p>这里给出我的解决办法，在页面加载时执行一小段js代码，方法非常简单，伪代码如下：</p> <div class="language- extra-class"><pre class="language-text"><code>function utm_restore() {
  if (页面url没有UTM参数 &amp;&amp; referer有UTM参数) {
    提取referer的UTM参数并加入页面的url中
  }
}
</code></pre></div><p>相当于是referer和query双保险，确保UTM参数在网站内的跳转不会丢失。</p> <h1 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h1> <ul><li><a href="https://en.wikipedia.org/wiki/HTTP_referer" target="_blank" rel="noopener noreferrer">Wikipedia: HTTP Referer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://portswigger.net/kb/issues/00500400_cross-domain-referer-leakage" target="_blank" rel="noopener noreferrer">Portswigger: cross-domain-referer-leakage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.w3.org/TR/referrer-policy/" target="_blank" rel="noopener noreferrer">W3C: referer-policy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://en.wikipedia.org/wiki/UTM_parameters" target="_blank" rel="noopener noreferrer">Wikipedia: UTM paremeters<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <div class="comment" data-v-63da4bd6><Vssue data-v-63da4bd6></Vssue></div></div></div> <div class="container" data-v-07c4fbe2 data-v-ad494eec>
  Designed by <a href="/about" data-v-07c4fbe2>Lishunyang</a> | <a href="https://beian.miit.gov.cn/" target="_blank" data-v-07c4fbe2>京ICP备20009157号</a> | All right reserved
</div></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.a48c4f56.js" defer></script><script src="/blog/assets/js/2.e0432708.js" defer></script><script src="/blog/assets/js/28.3aaeec56.js" defer></script>
  </body>
</html>
