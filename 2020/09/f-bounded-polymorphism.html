<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>F-bounded Polymorphism | Lishunyang&#39;s Blog</title>
    <meta name="description" content="Lishunyang&#39;s Blog">
    <link rel="icon" type="image/png" href="/blog/favicon.png">
  <meta name="keywords" content="Javascript,HTTP,Nodejs,React">
    
    <link rel="preload" href="/blog/assets/css/0.styles.9d0cb107.css" as="style"><link rel="preload" href="/blog/assets/js/app.c8d67ad9.js" as="script"><link rel="preload" href="/blog/assets/js/3.acd1c8f7.js" as="script"><link rel="preload" href="/blog/assets/js/42.2f7e406e.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.9d0cb107.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-v-ad494eec><ul class="container" data-v-37370f15 data-v-ad494eec><li class="title" data-v-37370f15><a href="/blog/" data-v-37370f15><img src="/blog/assets/img/avatar.cf743a85.jpg" class="avatar" data-v-37370f15>Lishunyang's Blog</a></li> <li class="item" data-v-37370f15><a href="/blog/about.html" data-v-37370f15>About</a></li></ul> <div class="main" data-v-ad494eec><div class="container" data-v-63da4bd6 data-v-ad494eec><div class="header" data-v-63da4bd6><h1 class="title" data-v-63da4bd6>F-bounded Polymorphism</h1> <div class="date-and-tags" data-v-63da4bd6><span class="date" data-v-63da4bd6>2020/9/22</span> <!----></div></div> <ul class="sidebar" data-v-63da4bd6><li class="sidebar-item" data-v-63da4bd6><a href="/2020/09/f-bounded-polymorphism.html#子类型（subtype）" data-v-63da4bd6>子类型（subtype）</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2020/09/f-bounded-polymorphism.html#协变（covariance）、逆变（contravariance）、不可变（invariance）" data-v-63da4bd6>协变（Covariance）、逆变（Contravariance）、不可变（Invariance）</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2020/09/f-bounded-polymorphism.html#限定泛型（bounded-polymorphism）" data-v-63da4bd6>限定泛型（Bounded Polymorphism）</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2020/09/f-bounded-polymorphism.html#f-bounded-polymorphism" data-v-63da4bd6>F-bounded Polymorphism</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2020/09/f-bounded-polymorphism.html#参考资料" data-v-63da4bd6>参考资料</a></li></ul> <div class="content" data-v-63da4bd6><div class="content__default" data-v-63da4bd6><h2 id="子类型（subtype）"><a href="#子类型（subtype）" class="header-anchor">#</a> 子类型（subtype）</h2> <p>面向对象编程中，我们可以简单地认为对象就是键值对。</p> <p>比如直角坐标系中的点（Point）对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
</code></pre></div><p>其对应的类型是：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Point</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
</code></pre></div><p>假设现在有这样一个对象：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">'red'</span> <span class="token punctuation">}</span>
</code></pre></div><p>其对应的类型是：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">ColoredPoint</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> color<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span>
</code></pre></div><p>可以看到，<code>ColoredPoint</code>包含了<code>Point</code>的全部信息，此外还多了一个color信息，信息越多越具体（特化），所以我们就说<code>ColoredPoint</code>是<code>Point</code>的子类型（subtype）。</p> <p>这个其实是比较容易理解的，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>植物 -&gt; 水果 -&gt; 苹果 -&gt; 黄元帅苹果
</code></pre></div><p>越往右，信息越多越具体，右边都是左边的子类型。</p> <p>因而在面向对象编程中，子类型的对象可以赋值给父类型的对象，即：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> apple<span class="token operator">:</span>Apple <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fruit<span class="token operator">:</span>Fruit <span class="token operator">=</span> apple<span class="token punctuation">;</span>
</code></pre></div><p>这个过程无需强制类型转换，因为上述子类型的定义符合<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener noreferrer">里氏替换原则<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这样写一定不会出错。</p> <blockquote><p>里氏替换原则通俗版：子类对象可以在程序中替换父类对象</p></blockquote> <p>关于里氏替换原则，也可以这样理解：父类型是大人，子类型是小孩。现在一群人满满当当挤在电梯里，你可以把一个大人替换成一个小孩，但是反之不行。也就是，更小的类型可以替换更大的类型。</p> <h2 id="协变（covariance）、逆变（contravariance）、不可变（invariance）"><a href="#协变（covariance）、逆变（contravariance）、不可变（invariance）" class="header-anchor">#</a> 协变（Covariance）、逆变（Contravariance）、不可变（Invariance）</h2> <p>函数是否也有子类型呢？因为函数有参数和返回值，那我们先用控制变量法，只观察参数类型或返回值类型不同的函数。</p> <p>首先来看参数类型相同而返回值类型不同的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">drawPoint</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">x</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> Point <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">drawRedPoint</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">x</span><span class="token operator">:</span> number<span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span><span class="token operator">:</span> RedPoint <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">'red'</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>想象一下，如果我们把代码中所有的<code>drawPoint</code>都替换成<code>drawRedPoint</code>，这应该是没有问题的（返回的对象多了一个color字段，没有什么影响），而反之是有问题的。那么根据里氏替换原则，<code>drawRedPoint</code>是<code>drawPoint</code>的子类型。</p> <p>抽象一下总结出来就是，对于参数类型相同的两个函数，返回值类型越小，函数类型越小。emmmm其实类型可没有大小之分，这里是借用之前电梯的那个例子，总之理解我的意思就好。</p> <p>再来看看返回值类型相同而参数类型不同的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">logPoint</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">point</span><span class="token operator">:</span> Point</span><span class="token punctuation">)</span><span class="token operator">:</span> string <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">logRedPoint</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">redPoint</span><span class="token operator">:</span> RedPoint</span><span class="token punctuation">)</span><span class="token operator">:</span> string <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>redPoint<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>同样地，如果把代码中所有的<code>logRedPoint</code>替换成<code>logPoint</code>，这应该是不会报错的（原来的参数一定有color字段，现在无所谓了），而反之是有问题的。那么根据里氏替换原则，<code>logPoint</code>是<code>logRedPoint</code>的子类型。</p> <p>抽象一下总结就是，对于返回值类型相同的参数，参数类型越大，函数类型越小。同理理解我意思就好。</p> <p>最后，如果函数的参数和返回值类型都不相同，那么我们可以定义：参数类型更大且返回值类型更小的函数类型更小，参数类型更小且返回值类型更大的函数类型更大，其他情况无法比较大小（也就是没有不算子类型）。</p> <p>用数学符号表示即：</p> <div class="language- extra-class"><pre class="language-text"><code>if s' &lt;= s and t &lt;= t' then s-&gt;t &lt;= s'-&gt;t'
</code></pre></div><p>这里还有一个与之对偶的有趣结论，如果我们把函数固定下来，尝试改变参数和返回值的赋值类型。比如下面这个函数，正常情况下调用该函数，参数是<code>Point</code>类型，而返回值的赋值对象是<code>RedPoint</code>类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>point<span class="token operator">:</span> Point<span class="token punctuation">)</span><span class="token operator">:</span> RedPoint
</code></pre></div><p>实际上，如果我们在调用该函数的时候，把参数换成<code>RedPoint</code>类型，或者把返回值的赋值对象换成<code>Red</code>类型，这都是没有问题的。即：</p> <ol><li>有些地方，我们可以使用比原本设定的类型更小的类型（比如函数的参数）</li> <li>有些地方，我们可以使用比原本设定的类型更大的类型（比如函数的返回值的赋值变量类型）。</li></ol> <p>第一种情况就叫做协变（Covariance），这是最符合直觉的一种场景，第二种情况叫逆变（Contravariance），这个乍一看不太符合直觉。当然除了协变和逆变之外，如果既不能换成大的也不能换成小的，那就叫不可变（Invariance），这种场景也是存在的。</p> <p>简单的记忆结论就是：参数可协变，返回值可逆变</p> <h2 id="限定泛型（bounded-polymorphism）"><a href="#限定泛型（bounded-polymorphism）" class="header-anchor">#</a> 限定泛型（Bounded Polymorphism）</h2> <p>前文啰嗦了一大堆，总算讲到了正文了，我们先看一看什么叫限定泛型。当然，这里假设你已经知道什么叫泛型了（Polymorphism/Quantification/Generic等）。</p> <p>限定泛型，的意思就是，限定了的泛型。</p> <p>比如下面的函数，判断一个东西美不美：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">isBeautiful</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>something<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span>
</code></pre></div><p>本来泛型T可以是任意类型，比如可以是植物、动物、建筑等，没有任何限制。现在我们像限制一下T只能是动物的子类型，即：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">isBeautiful</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Animal<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>something<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span>
</code></pre></div><p>这就叫做限定泛型（Bounded Polymorphism），可以看到，其实就是对参数增加了一个协变。</p> <h2 id="f-bounded-polymorphism"><a href="#f-bounded-polymorphism" class="header-anchor">#</a> F-bounded Polymorphism</h2> <p>抱歉不知道中文该怎么翻译，有人叫“有界限定泛型”，我觉得不是很贴切。至于为什么叫F-bounded Polymorphism，可以看最初的<a href="http://staff.ustc.edu.cn/~xyfeng/teaching/FOPL/lectureNotes/CookFBound89.pdf" target="_blank" rel="noopener noreferrer">论文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，当时的作者也不知道该起什么名字，索性就拿举例子的函数字母F加个前缀吧，于是就叫做F-bounded Polymorphism。</p> <p>为什么有这么个玩意呢？</p> <p>回到之前泛型的例子，假如现在的函数是从两个东西里挑出最美的那一个：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">pickMostBeautiful</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>
</code></pre></div><p>还是一样，现在想限定一下是从动物中挑选，那么我们会下意识地这样写：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">pickMostBeautiful</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Animal<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>
</code></pre></div><p>因为我们期望达到这样的效果：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> mostBeautiful<span class="token operator">:</span> Cat <span class="token operator">=</span> <span class="token generic-function"><span class="token function">pickMostBeautiful</span><span class="token generic class-name"><span class="token operator">&lt;</span>Cat<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
</code></pre></div><p>上面的代码，我们会注意到<code>Cat</code>类型作为了函数返回值赋值的类型，相比于最初的泛型函数，相当于是类型缩小了，也就是发生了协变，而我们知道，函数的返回值赋值变量只能逆变，这这这这这，不是矛盾了吗？！</p> <p>当当当当，F-bounded Polymorphism登场了：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> mostBeautiful<span class="token operator">:</span> <span class="token constant">F</span><span class="token punctuation">[</span>Cat<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">pickMostBeautiful</span><span class="token generic class-name"><span class="token operator">&lt;</span>Cat<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
</code></pre></div><p>这里，把原来的<code>Cat</code>换了个记号<code>F[Cat]</code>，其中的F是一个函数，将一个类型转换成另一个类型。</p> <p>F的定义是：<code>F[t] = σ</code>，且<code>t</code>是<code>σ</code>的子类型。即：σ是来源于t（用F作用于t得到的），而t呢又是来源于σ（子类型的定义），于是σ和t就产生了递归了，这就叫做F-bounded Polymorphism。可见F-bounded Polymorphism其实也是一种Bounded Polymorphism，只是带有递归的Bounded Polymorphism。</p> <p>回到上面的代码，因为<code>Cat</code>是<code>F[Cat]</code>的子类型，所以是逆变，圆上了。</p> <p>就好比先有鸡还是先有蛋，这个问题争论起来没有答案，但是在实际情况中不管是先有鸡还是先有蛋，世界都能正常运转，于其纠结于此（compile time），不如引入一个递归的概念把理论说通了，反正现实中（runtime）都很明确了，不打紧。</p> <p>另一个比较实际的例子是class的this的类型，这里就不啰嗦了，可以看TS的官方文档：<a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types" target="_blank" rel="noopener noreferrer">点击这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>如果到这里你是一头雾水，那就对了，多琢磨琢磨，找找感觉吧。</p> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li><a href="http://staff.ustc.edu.cn/~xyfeng/teaching/FOPL/lectureNotes/CookFBound89.pdf" target="_blank" rel="noopener noreferrer">F-Bounded Polymorphism for Object-Oriented Programming<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://courses.cs.washington.edu/courses/cse505/99au/oo/f-bounded.html" target="_blank" rel="noopener noreferrer">Very Rough Notes on F-Bounded Polymorphism<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" target="_blank" rel="noopener noreferrer">Covariance and contravariance<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance" target="_blank" rel="noopener noreferrer">泛型中的协变和逆变<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener noreferrer">Liskov substitution principle<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://codingwithstyle.blogspot.com/2015/07/f-bounded-polymorphism.html" target="_blank" rel="noopener noreferrer">F-Bounded Polymorphism in Java<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://work.tinou.com/2009/07/wtf-is-fbounded-polymorphism.html" target="_blank" rel="noopener noreferrer">WTF is F-Bounded Polymorphism<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://en.wikipedia.org/wiki/Bounded_quantification" target="_blank" rel="noopener noreferrer">Bounded quantification<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <div class="comment" data-v-63da4bd6><!----></div></div></div> <div class="container" data-v-07c4fbe2 data-v-ad494eec>
  Designed by <a href="/about" data-v-07c4fbe2>Lishunyang</a> | <a href="https://beian.miit.gov.cn/" target="_blank" data-v-07c4fbe2>京ICP备20009157号</a> | All right reserved
</div></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.c8d67ad9.js" defer></script><script src="/blog/assets/js/3.acd1c8f7.js" defer></script><script src="/blog/assets/js/42.2f7e406e.js" defer></script>
  </body>
</html>
