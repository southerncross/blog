<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>下载和HTTP header的二三事 | Lishunyang&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" type="image/png" href="/blog/favicon.png">
    <meta name="description" content="Lishunyang&#39;s Blog">
    <meta name="keywords" content="Javascript,HTTP,Nodejs,React">
    
    <link rel="preload" href="/blog/assets/css/0.styles.102d8b8d.css" as="style"><link rel="preload" href="/blog/assets/js/app.a48c4f56.js" as="script"><link rel="preload" href="/blog/assets/js/2.e0432708.js" as="script"><link rel="preload" href="/blog/assets/js/14.f21e0cd0.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.102d8b8d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-v-ad494eec><ul class="container" data-v-26d88251 data-v-ad494eec><li class="title" data-v-26d88251><a href="/blog/" data-v-26d88251><img src="/blog/assets/img/avatar.cf743a85.jpg" class="avatar" data-v-26d88251>Lishunyang's Blog</a></li> <li class="item" data-v-26d88251><a href="/about.html" data-v-26d88251>About</a></li></ul> <div class="main" data-v-ad494eec><div class="container" data-v-63da4bd6 data-v-ad494eec><div class="header" data-v-63da4bd6><h1 class="title" data-v-63da4bd6>下载和HTTP header的二三事</h1> <div class="date-and-tags" data-v-63da4bd6><span class="date" data-v-63da4bd6>2020/2/29</span> <!----></div></div> <!----> <div class="content" data-v-63da4bd6><div class="content__default" data-v-63da4bd6><h1 id="用a标签下载"><a href="#用a标签下载" class="header-anchor">#</a> 用a标签下载</h1> <p>我们经常能在页面中看到一些下载链接，比如Nodejs的下载页</p> <p><img src="/blog/assets/img/nodejs_download.53aba7af.png" alt="nodejs downloading page"></p> <p>如果观察html源代码你会发现，这其实就是个a标签：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://nodejs.org/dist/v12.16.1/node-v12.16.1-x64.msi<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>12.16.1 LTS<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>看上去就是一个普通的a标签而已，我们知道a标签的默认行为应该是打开一个页面才对，你有没有想过为什么这里的a标签不是打开一个页面而是触发了下载行为呢？</p> <h1 id="mime"><a href="#mime" class="header-anchor">#</a> MIME</h1> <p>你也许听说过<code>Content-Type</code>这个header，没错，当我们点击那个a标签时，浏览器检查了response的Content-Type，发现这是一个特殊的类型，因而触发了下载行为。如果你打开浏览器的调试工具看的话，上面的下载链接的Content-Type实际上是<code>application/octet-stream</code>。</p> <p><img src="/blog/assets/img/octet_stream_header.68c0fd29.png" alt="application/octet-stream"></p> <p>而如果一个链接的response header的Content-Type是<code>text/html</code>的话，浏览器就会打开页面，比如点击<a href="https://blog.lishunyang.com/" target="_blank" rel="noopener noreferrer">“这里”<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>将打开博客首页，我们可以发现Content-Type是<code>text/html</code>。</p> <p><img src="/blog/assets/img/html_header.0c3154a4.png" alt="text/html"></p> <p>Content-Type头部的内容实际上是MIME类型，它的全称是Multipurpose Internet Mail Extension，没错这个标准一开始被发明出来是用来扩展邮件的，要知道邮件比互联网出现得更早，很多现在的互联网标准其实最初都是用在邮件里的。如果你想更多细节，可以参考wikipedia对MIME的介绍，这里是<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95" target="_blank" rel="noopener noreferrer">传送门<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>MIME的最常见格式为</p> <div class="language- extra-class"><pre class="language-text"><code>[type]/[subtype]; parameter
</code></pre></div><p>其中，type常见的值有以下几种：</p> <ul><li>text：文本信息</li> <li>application：应用数据</li> <li>image：图片</li> <li>audio：音频</li> <li>video：视频</li> <li>multipart：由多个部分组合而成的数据，比如表单数据</li></ul> <p>而subtype则根据type不同而不同，比如刚才见到的<code>application/octet-stream</code>和<code>text/html</code>，其他比较常见的还有<code>application/json</code>，<code>img/png</code>，<code>text/javascript</code>，<code>text/css</code>等等。总之，浏览器就是根据这个MIME来识别不同的response，并决定如何处理它。例如前面的a标签，如果url的Content-Type是audio，Chrome浏览器会打开一个内置的音频播放器。浏览器的network面板也是根据Content-Type来对网络请求分类的：</p> <p><img src="/blog/assets/img/chrome_network_type.9f428935.png" alt="chrome network panel"></p> <p>需要强调的是，Content-Type这个header不仅用于response，同样可以用于request。比如向服务器提交表单或上传文件，request里也有Content-Type这个header：</p> <p><img src="/blog/assets/img/upload_header.d95eb5ec.png" alt="request header"></p> <blockquote><p>PS：上传文件时的Content-Type与文件内容无关，总是multi-part/form-data</p></blockquote> <h1 id="content-type-sniffing"><a href="#content-type-sniffing" class="header-anchor">#</a> Content-Type Sniffing</h1> <p>Content-Type既然是个header，就需要开发者人为指定，如果Content-Type缺失的话会怎么样呢？</p> <p>比如在浏览器中输入一个不带Content-Type的请求地址，当请求发出后，浏览器如何决定呢？可以写一个简单的node应用进行测试</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 加载了一个图片并返回</span>
  fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">'./hello.png'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>经过测试发现，浏览器是能够正确渲染出图片的。这是因为浏览器在Content-Type缺失的情况下会主动分析响应体内容然后猜测MIME类型，这个过程叫做Content-Type Sniffing，关于如何猜测，有一个专门的规范，见<a href="https://mimesniff.spec.whatwg.org/" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>Content-Type Sniffing的本意是好的，但这可能会导致XSS安全问题。</p> <p>假设某网站允许用户上传图片做头像，但是在响应请求的时候没有附带Content-Type，那么这个请求该如何展示将由浏览器通过Content-Sniffing确定。此时黑客可以构造一个恶意html，将其改名为avatar.png然后上传到服务器上（很多服务器对文件类型的限制就是简单地通过后缀名过滤），那么之后当其他用户打开这个恶意头像链接时，浏览器会通过Content-Type Sniffing判定为这是一个html并正常加载，从而导致XSS问题。比如下面的演示：</p> <p>黑客构造一段恶意html代码，并将其改名为<code>avatar.png</code>，恶意代码内容为：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'XSS'</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>下面是无Content-Type的server端代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">'.'</span> <span class="token operator">+</span> req<span class="token punctuation">.</span>url <span class="token operator">+</span> <span class="token string">'.png'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8848</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>打开浏览器，输入 http://localhost:8848/avatar，看到代码被执行了：</p> <p><img src="/blog/assets/img/sniffing_xss.4e322c6a.png" alt="xss in content type sniffing"></p> <p>幸运的是，有一个X-Content-Type-Options头部可以解决这个问题，当设置这个头部为nosniff时，浏览器将不会猜测MIME，缺失的Content-Type将会一律按照text/plain解析。</p> <p>比如上面的例子，如果后端增加了nosniff的头部，浏览器将不会猜测MIME而是将使用默认的text/plain类型：</p> <p><img src="/blog/assets/img/xcto_nosniff.e52f4874.png" alt="nosniff"></p> <h1 id="content-disposition"><a href="#content-disposition" class="header-anchor">#</a> Content-Disposition</h1> <p>回到最开头的下载问题，现在我们知道了，a标签的行为取决于资源响应的Content-Type，如果是text/html，那么浏览器将会打开新的页面。现在问题来了，如果要下载的文件本身是一个html，怎么办呢？</p> <p>将Content-Type手动修改为application/octet-stream可以吗？当然可以，这样浏览器就会认为a标签引用的是一个二进制文件，直接触发下载行为。但是这样做显得太暴力了，下载文件的类型信息丢失了，有没有其他办法呢？</p> <p>当然是有的了，那就是Content-Disposition这个header。Content-Disposition可以告诉浏览器，获取到的资源是展示还是下载，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Disposition: attachment; filename=hello.html
</code></pre></div><p>这样，我们就可以让Content-Type是text/html，同时浏览器也能正确识别并下载html文件了。</p> <p>但是！Content-Disposition带来了新的安全风险。如果存在HTTP Header注入漏洞，Content-Disposition可能会失效。</p> <p>假如有一个网盘站点，允许用户上传下载资料，所有的下载请求都添加了Content-Disposition以确保文件内容不会被浏览器解析。但如果黑客可以注入HTTP header，比如在Set-Cookie当中添加<code>\r\n\r\n</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: something
                              &lt;-- 注意这里的\r\n

Content-Disposition: attachment;filename=xss.htm


&lt;script&gt;alert(document.cookie)&lt;/script&gt;
</code></pre></div><blockquote><p>HTTP协议规定两个连续的<code>\r\n</code>代表header和body的分隔</p></blockquote> <p>下面的Content-Disposition被当成了body的一部分，于是浏览器将会按照Content-Type是text/html的方式解析文件内容，Content-Disposition这个限制被绕过了，XSS又发生了！</p> <blockquote><p>关于HTTP header injection的资料可以参考<a href="https://owasp.org/www-community/attacks/HTTP_Response_Splitting" target="_blank" rel="noopener noreferrer">OWASP的wiki<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>正因为Content-Disposition的安全问题，即使已经被广泛使用，这个其实header并没有被收录在HTTP1.1协议中，因此，使用Content-Disposition的方法不是推荐的做法。</p> <h1 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h1> <p>其实这里演示的是常规的后端下载，如果算上ObjectURL前端下载，有关下载的内容还可以再扯下去，不过这里就先就此打住吧。</p> <p>总结：</p> <ol><li>Content-Type决定了浏览器如何处理请求得到的资源</li> <li>Content-Type如果缺失，浏览器会尝试猜测MIME类型，而这可能导致XSS风险，请务必使用X-Content-Type-Options: nosniff</li> <li>Content-Disposition也可以决定资源是加载还是展示，但是可以被HTTP Header Inject绕过，所以不推荐使用</li></ol> <h1 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h1> <ul><li><a href="https://en.wikipedia.org/wiki/MIME" target="_blank" rel="noopener noreferrer">MIME wikipedia<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types" target="_blank" rel="noopener noreferrer">常见MIME类型列表<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.denimgroup.com/resources/blog/2019/05/mime-sniffing-in-browsers-and-the-security-implications/" target="_blank" rel="noopener noreferrer">MIME Sniffing in Browsers and the Security Implications<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://markitzeroday.com/xss/bypass/2018/04/17/defeating-content-disposition.html" target="_blank" rel="noopener noreferrer">Defeating Content-Disposition<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://owasp.org/www-community/attacks/HTTP_Response_Splitting" target="_blank" rel="noopener noreferrer">OWASP HTTP Response Splitting<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <div class="comment" data-v-63da4bd6><Vssue data-v-63da4bd6></Vssue></div></div></div> <div class="container" data-v-07c4fbe2 data-v-ad494eec>
  Designed by <a href="/about" data-v-07c4fbe2>Lishunyang</a> | <a href="https://beian.miit.gov.cn/" target="_blank" data-v-07c4fbe2>京ICP备20009157号</a> | All right reserved
</div></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.a48c4f56.js" defer></script><script src="/blog/assets/js/2.e0432708.js" defer></script><script src="/blog/assets/js/14.f21e0cd0.js" defer></script>
  </body>
</html>
