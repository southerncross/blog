<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>迁移Dva项目到typescript有感 | Lishunyang&#39;s Blog</title>
    <meta name="description" content="Lishunyang&#39;s Blog">
    <link rel="icon" type="image/png" href="/blog/favicon.png">
  <meta name="keywords" content="Javascript,HTTP,Nodejs,React">
    
    <link rel="preload" href="/blog/assets/css/0.styles.1049df1f.css" as="style"><link rel="preload" href="/blog/assets/js/app.c3af64bb.js" as="script"><link rel="preload" href="/blog/assets/js/3.6f4cefaa.js" as="script"><link rel="preload" href="/blog/assets/js/21.b446c399.js" as="script">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.1049df1f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-v-ad494eec><ul class="container" data-v-26d88251 data-v-ad494eec><li class="title" data-v-26d88251><a href="/blog/" data-v-26d88251><img src="/blog/assets/img/avatar.cf743a85.jpg" class="avatar" data-v-26d88251>Lishunyang's Blog</a></li> <li class="item" data-v-26d88251><a href="/about.html" data-v-26d88251>About</a></li></ul> <div class="main" data-v-ad494eec><div class="container" data-v-63da4bd6 data-v-ad494eec><div class="header" data-v-63da4bd6><h1 class="title" data-v-63da4bd6>迁移Dva项目到typescript有感</h1> <div class="date-and-tags" data-v-63da4bd6><span class="date" data-v-63da4bd6>2021/4/5</span> <span class="tags" data-v-63da4bd6><span class="tag" data-v-63da4bd6>typescript</span><span class="tag" data-v-63da4bd6>dva</span></span></div></div> <ul class="sidebar" data-v-63da4bd6><li class="sidebar-item" data-v-63da4bd6><a href="/2021/04/migrate-dva-to-ts.html#前置动作" data-v-63da4bd6>前置动作</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2021/04/migrate-dva-to-ts.html#摸着自己过河" data-v-63da4bd6>摸着自己过河</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2021/04/migrate-dva-to-ts.html#社区的解决方案" data-v-63da4bd6>社区的解决方案</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2021/04/migrate-dva-to-ts.html#约定式之殇" data-v-63da4bd6>约定式之殇</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2021/04/migrate-dva-to-ts.html#如何正确得到-action-类型" data-v-63da4bd6>如何正确得到 action 类型</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2021/04/migrate-dva-to-ts.html#generator-的问题" data-v-63da4bd6>generator 的问题</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2021/04/migrate-dva-to-ts.html#没有全局的-state-类型" data-v-63da4bd6>没有全局的 state 类型</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2021/04/migrate-dva-to-ts.html#自动推导-model-类型？" data-v-63da4bd6>自动推导 model 类型？</a></li><li class="sidebar-item" data-v-63da4bd6><a href="/2021/04/migrate-dva-to-ts.html#后记" data-v-63da4bd6>后记</a></li></ul> <div class="content" data-v-63da4bd6><div class="content__default" data-v-63da4bd6><blockquote><p>2021.9.13 更新：完整的类型代码已上传 github，见<a href="https://github.com/Moka-FE/dva-types" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>最近一直在捣鼓一个事情，就是将一个基于 Dva 的 React 项目从 js 迁移到 ts，踩了很多坑，决定分享一下。</p> <h2 id="前置动作"><a href="#前置动作" class="header-anchor">#</a> 前置动作</h2> <blockquote><p>问：把大象装进冰箱分几步？</p></blockquote> <p>最直观的想法是“渐进式迁移”，即：新代码尽量用 ts 写，老代码慢慢重构成 ts。这也是很多大规模重构首选的策略，比如国际化。但在实际执行的时候你会发现一个大问题，类型推导特别麻烦。类型推导，类型推导，它是基于已有的类型推导，如果没有类型那是推不出来的。而项目迁移刚开始的时候这部分恰恰是缺失的（比如 API 返回的数据类型、redux 全局状态中的类型），巧妇难为无米之炊。没有充分利用类型推导能力的 ts 代码，就好像这样：</p> <p><img src="/blog/assets/img/ts-without-type-inference.db814d5b.png" alt="ts withou type inference"></p> <p>因此，迁移大项目到 ts，首先要做的第一步应该是<strong>手动补全关键类型定义</strong>，这一步完成了，才可以进行后续的迁移动作。</p> <p>那么什么样的类型需要补全呢？</p> <p>其实这个问题的答案也不难想到，有些类型是可以通过类型推导得到的，那么这样的类型就不必手动补全，而有些类型无法通过类型推导得到，这些类型就是我们需要手动补全的类型。什么样的类型是无法通过推导得到的呢？一路顺藤摸瓜向源头找，通常你会发现这些东西来自外部 API，然后以全局状态的形式留在了 redux 这样的地方被各处引用。</p> <p>答案呼之欲出了，迁移老项目，应该先从迁移全局状态开始。当你把全局状态的类型定义都补充得差不多的时候，此时就可以开始正式的 ts 迁移了。</p> <p>那么接下来就来聊聊 Dva 迁移到 ts 的一些坑。</p> <h2 id="摸着自己过河"><a href="#摸着自己过河" class="header-anchor">#</a> 摸着自己过河</h2> <p>react-redux 官方文档中有一篇<a href="https://react-redux.js.org/using-react-redux/usage-with-typescript" target="_blank" rel="noopener noreferrer">Usage with TypeScript<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提到了 react-redux 的 ts 用法，如果你只用到了 react-redux，那么参考这一篇就基本足够了，基本不会遇到大问题。</p> <p>如果你的项目使用了 redux-saga，那么很不幸，对 generator 的处理会非常蛋疼，redux-saga 官方也没有给出推荐的做法，你只能依赖于社区经验，比如这一篇<a href="https://tech.lalilo.com/redux-saga-and-typescript-doing-it-right" target="_blank" rel="noopener noreferrer">Redux-saga and Typescript, doing it right<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，还有这一篇<a href="https://enetoolveda.medium.com/how-to-use-redux-saga-typescript-like-a-pro-523b97143303" target="_blank" rel="noopener noreferrer">How To Use Redux Saga/Typescript Like a pro!<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。总的来说，写起来会比较蛋疼，勉强可以接受。</p> <p>而如果你的项目使用了 Dva，除了上面提到的 redux-saga 的问题之外，你还将遇到 Dva 特有的一堆问题。Dva 官网至今都没有给出 ts 的指南（实际上是给不出，后面会分析），Umi 官网倒是给了一个小例子，但那个例子可以说是“毫无诚意”，基本上就是手动添加了各种类型让 ts 编译不报错而已，几乎没有任何参考价值。不仅官网不给力，dva 社区也同样不给力，基本上找不到有用的社区实践经验，即便找到了，通常都是玩具级别的 demo，糊弄小孩呢。</p> <p>没办法，那就只能自己摸索了，摸着自己过河吧。</p> <h2 id="社区的解决方案"><a href="#社区的解决方案" class="header-anchor">#</a> 社区的解决方案</h2> <p>给 Dva 补全类型，本质上就是给 model 添加类型，该怎么做呢？我们先看看社区的解决办法。</p> <p>第一种办法，利用 dva 内置的一些通用类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> EffectsCommandMap<span class="token punctuation">,</span> Model <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'dva'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AnyAction<span class="token punctuation">,</span> Reducer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Effect</span> <span class="token operator">=</span> <span class="token punctuation">(</span>
  action<span class="token operator">:</span> AnyAction<span class="token punctuation">,</span>
  effects<span class="token operator">:</span> EffectsCommandMap <span class="token operator">&amp;</span> <span class="token punctuation">{</span> select<span class="token operator">:</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function-variable function">func</span><span class="token operator">:</span> <span class="token punctuation">(</span>state<span class="token operator">:</span> StateType<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">State</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">TestModel</span> <span class="token punctuation">{</span>
  namespace<span class="token operator">:</span> <span class="token string">'test'</span><span class="token punctuation">;</span>
  state<span class="token operator">:</span> State<span class="token punctuation">;</span>
  reducers<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// reducers里几乎没有类型限定</span>
    foo<span class="token operator">:</span> Reducer<span class="token operator">&lt;</span>State<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  effects<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// effects里几乎没有类型限定</span>
    bar<span class="token operator">:</span> Effect<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 最后是具体model实现</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> testModel<span class="token operator">:</span> TestModel <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种写法的类型限定太宽松了，对 reducer 和 effect 函数几乎就没有限制，除了让 ts 类型检查不报错以外实用价值很低，跟直接用 javascript 写没什么区别，属于自欺欺人式的写法。</p> <p>还有一种社区方案是这样，简单来说就是在第一种的基础上把 reducer 和 effect 函数的类型写得更详细了：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">TestState</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">TestModel</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  namespace<span class="token operator">:</span> <span class="token string">'test'</span><span class="token punctuation">;</span>
  state<span class="token operator">:</span> TestState<span class="token punctuation">;</span>
  reducers<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// reducers里的函数起码有了参数和返回值的限定</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>state<span class="token operator">:</span> TestState<span class="token punctuation">,</span> action<span class="token operator">:</span> <span class="token punctuation">{</span> payload<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> TestState<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  effects<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">// effects里的函数起码有了参数和返回值的限定</span>
    <span class="token function">bar</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">{</span> payload<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 最后是具体model实现</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> model<span class="token operator">:</span> TestModel <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种写法，reducer 和 effect 函数内部至少能做一些类型检查了，但也就仅此而已了，在触发 reducer 和 effect 的地方仍然是没有类型检查的，下面这种错误是无法检查发现的，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'tset'</span><span class="token punctuation">,</span> <span class="token comment">// test拼写错误</span>
  <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token comment">// 忘记写payload</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="约定式之殇"><a href="#约定式之殇" class="header-anchor">#</a> 约定式之殇</h2> <p>仔细想想，reducer 或 effect 都是通过 dispatch action 触发的，因而导致上述问题的根本原因在于我们还缺失了 action 的类型。如何得到 action 的类型呢？等等！我们在 Dva 里似乎从来没有定义过 action 呀！比如下面是一个非常典型的 dva model，里面的 action 只在 reducer 和 effect 函数中作为参数出现，action 是什么压根就没有定义过。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">namespace</span><span class="token operator">:</span> <span class="token string">'test'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">reducers</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">effects</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>其实 action 并不是没有定义，只是这个定义 action 的过程被 Dva 给封装起来了，它会在运行时对 model 类型做处理，动态生成 action 的定义，这是一个约定的行为。这种写法也就是常说的约定式编程。</p> <p>约定式编程最大好处就是写起来省事儿，可以省略很多样板代码，让开发者把精力放在重要的事情上面，开发者也很喜欢这种做法（毕竟懒是天性）。但约定式编程也有很多缺点，其中最大的缺点在于<strong>约定式写法无法获得完整的静态检查</strong>，这是因为“约定的东西”是运行时生效的，而静态检查发生在编译时，君生我未生，我生君已老。</p> <p>在 javascript 时代，这个缺点还好，因为 js 代码总是充满各种运行时的 hack，但是到了 typescript 时代，这个缺点就很严重了。因为 ts 的核心价值“静态类型检查”它是静态检查，前面说过了，约定式享受不到静态类型检查的福利，而 ts 编译器又无法理解约定写法的含义，结果就是这些约定式写法在 ts 编译器眼中大概率会变成各种编译错误 😂</p> <p>在 typescript 时代，约定式的写法越多，越蛋疼，这就是所谓的约定式之殇。</p> <p>Dva 会很贴心地根据 model 中的 reducers 和 effects 自动生成 action。比如还是之前的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> model <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">namespace</span><span class="token operator">:</span> <span class="token string">'test'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">reducers</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">effects</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Dva 会在运行时自动生成<code>test/foo</code>和<code>test/bar</code>这两个 action key。（甚至为了方便开发者，在当前 model 内部可以省略 namespace）</p> <p>除了 action 外，Dva 还会帮你把所有 models 目录下的 model 文件合并到一起，组成一个 global state（在 react-redux 中，开发者必须自己写一个 combine 过程）。这也是一个约定式的写法，所以在 Dva 中，完整的 state 类型也是很难得到的。当然这是后话了，后文会再次提到这个缺陷导致的一些影响。</p> <h2 id="如何正确得到-action-类型"><a href="#如何正确得到-action-类型" class="header-anchor">#</a> 如何正确得到 action 类型</h2> <p>虽然 Dva 的 action 是约定生成的，但这并不妨碍我们补全类型，最简单粗暴地，你可以直接手撕 action 类型，比如这样：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">TestAction</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token string">'test/foo'</span><span class="token punctuation">;</span>
  payload<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token string">'test/bar'</span><span class="token punctuation">;</span>
  payload<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token operator">...</span><span class="token punctuation">;</span>
</code></pre></div><p>千万别这么干，太傻了。</p> <p>我们想要的是更聪明的生成 action 类型的办法，比如可以编写一个工具类型，像是这样：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">/**
 * N: namespace
 * S: state
 * R: reducers
 * E: effects
 */</span>
<span class="token keyword">type</span> <span class="token class-name">GenerateAction<span class="token operator">&lt;</span><span class="token constant">M</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span> namespace<span class="token operator">:</span> <span class="token constant">N</span><span class="token punctuation">;</span> state<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">;</span> reducers<span class="token operator">:</span> <span class="token constant">R</span><span class="token punctuation">;</span> effects<span class="token operator">:</span> <span class="token constant">E</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>k <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">R</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">N</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>k<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span> <span class="token comment">// 拼接namespace和key</span>
    payload<span class="token operator">:</span> SecondParams<span class="token operator">&lt;</span><span class="token constant">R</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 取reducer函数的第二个参数为payload类型</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">R</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>k <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">E</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">N</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>k<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span> <span class="token comment">// 拼接namespace和key</span>
    payload<span class="token operator">:</span> FirstParam<span class="token operator">&lt;</span><span class="token constant">E</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 取effect函数的第一个参数为payload类型</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">E</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 构造得到TestAction类型</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">TestAction</span> <span class="token operator">=</span> GenerateAction<span class="token operator">&lt;</span>TestModel<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>当然实际的代码要比这个复杂一些，因为需要增加一些泛型限定，此外还要考虑某些没有 payload 的 action 类型（过滤掉 payload 属性）。</p> <p>有了 action 类型后，我们就可以干很多事情了。比如给 effect 的 command（比如 put）增加类型限定：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Commands<span class="token operator">&lt;</span>Action<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">put</span><span class="token operator">:</span> <span class="token punctuation">(</span>action<span class="token operator">:</span> Action<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 我们给TestModel类型的effect函数增加了新的类型约束</span>
<span class="token keyword">type</span> <span class="token class-name">TestModel</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  effects<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里对bar的第二个参数commands做了类型限定</span>
    <span class="token function">bar</span><span class="token punctuation">(</span>action<span class="token operator">:</span> TestAction<span class="token punctuation">,</span> commands<span class="token operator">:</span> Commands<span class="token operator">&lt;</span>TestAction<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样在具体使用的时候就可以检查出前文所说的错误了：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">default</span> testModel<span class="token operator">:</span> TestModel <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  effects<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span><span class="token function">bar</span><span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token punctuation">{</span> put <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这里会报类型错误，因为test拼写错了</span>
      <span class="token keyword">yield</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'tset'</span><span class="token punctuation">,</span> payload<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 这里会报类型错误，因为payload没写</span>
      <span class="token keyword">yield</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'test'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果是在 model 外部触发 action，则可以这样写，也可以达到一样的效果：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// dispatch本身支持一个泛型参数</span>
<span class="token generic-function"><span class="token function">dispatch</span><span class="token generic class-name"><span class="token operator">&lt;</span>TestAction<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">'test'</span><span class="token punctuation">,</span> payload<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>不仅是报错检查，在输入 type 的时候，IDE 还能自动提示和补全，简直不要太爽。</p> <h2 id="generator-的问题"><a href="#generator-的问题" class="header-anchor">#</a> generator 的问题</h2> <p>Dva 是基于 redux-saga 封装的，effect 的写法是 generator，这会导致一个小问题。比如我们有这样一个 generator：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>fetchSomething<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>假设我们已经给出了 call 和 fetchSomething 的类型，ts 能推导出<code>result</code>的类型吗？答案是不能，它的类型会被推导成 any。这是由于 generator 的用法决定的，yield 返回的类型跟 call 和 fetchSomething 没有关系，yield 返回的类型是外部调用 bar.next 时传入的类型，比如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传入的这个1才是result的值</span>
</code></pre></div><p>你可以回顾一下 yield 的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" target="_blank" rel="noopener noreferrer">用法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>也就是说，ts 无法自动推导出 generator 的 yield 类型，因而<strong>类型推导在 generator 的 yield 处会断开</strong>。</p> <p>上面的例子在实际编码中非常常见，从 2017 年开始就有人在 redux-saga 的 github 仓库中提出对应的 issue，希望 saga 官方能够改进这个问题，见<a href="https://github.com/redux-saga/redux-saga/issues/884" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。不过如前文所说，受限于 generator 本身的调用方式，改进的理论可能性是 0，也就是只能这样了。</p> <p><img src="/blog/assets/img/generator-any.5b5a4484.png" alt="still infer any"></p> <p>有一些民间解决办法，比如上图中提到的<a href="https://github.com/agiledigital/typed-redux-saga" target="_blank" rel="noopener noreferrer">typed-redux-saga<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它是魔改了<code>call</code>方法外加新的<code>yield*</code>语法实现的类型推导。当然魔改这种东西要引入新的 babel 插件，而且这些都不是官方的方案，大家都不太敢用。</p> <p>个人认为相对合理的做法是下面这种，注意多出来的<code>SagaReturnType</code>工具类型：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token operator">*</span><span class="token function">getUnreadMsgCount</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token punctuation">{</span> call<span class="token punctuation">,</span> put <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> response<span class="token operator">:</span> SagaReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> getUnreadMsgCount<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>getUnreadMsgCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>既然无法做到类型推导，那就打一点补丁吧。虽然需要手动增加类型，但好歹算是把类型推导给接上了。这就好比一个人骨折了，无法自行愈合，于是医生给你打上钢板帮你愈合。具体细节可以参考<a href="https://spin.atomicobject.com/2020/08/06/redux-saga-call-effect/" target="_blank" rel="noopener noreferrer">这篇文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="没有全局的-state-类型"><a href="#没有全局的-state-类型" class="header-anchor">#</a> 没有全局的 state 类型</h2> <p>组件里访问 redux 的 selector 写法是这样的（这也是 react-redux 官方推荐的写法）：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useSelector</span><span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token operator">:</span> GlobalState<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>test<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意那个 GlobalState，前面在讲约定式的时候有提到过，Dva 会按照约定拼接所有的 state，所以完整的 state 类型是无法靠 ts 推导出来的，换句话说，我们得不到 GlobalState。</p> <p>如果不加 GlobalState 的类型限定，下面的写法就会报错</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// state默认是any类型，这里的写法会报类型错误</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useSelector</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>同样地，想要得到 GlobalState 也不是不可以，有以下几种做法：</p> <p>第一种方法是手写代码引入所有 state 然后 combine 在一起得到 global state。这种做法的最大问题在于增加了代码的维护成本，新增 model 或者删除 model 都需要对 combine 代码做处理，而且这段代码没有实际效果，唯一的作用是让 ts 推导出类型，也现得有些鸡肋。</p> <p>第二种方法是将手写代码的过程自动化，魔改 dva 内部实现自动构造 combine 的代码。这种做法看似节省了维护成本，但实际上维护成本反而可能更高。因为自动生成的 combine 代码得进入代码仓库，多人协作时这种自动生成的代码很容易产生冲突，而且也不好处理（即使不进入代码仓库，那你本地多个分支间切换的时候也容易报冲突）。本质上这种做法是将项目的生命周期拆分出了一个预编译阶段，多了一个阶段，管理和维护成本其实要大很多。</p> <p>第三种做法是编写一个 vscode 插件，将第二步中的自动构造 combine 代码的过程放到插件里做，只要插件检测到是一个 dva 项目，就在后台自动构造产生 combine 代码。这样可以做到开发时无感知，也不用担心在什么时机触发预编译动作。当然，这种做法成本是比较高的，毕竟要开发一个 vscode 插件，如果团队里有人不用 vscode 而是要用 webstorm 怎么办，难道还要写一个 webstorm 插件吗？总之这种方案不是很靠谱。</p> <p>第四种做法是魔改 ts server，通过 ts 插件的方式增加新的报错检查和提示的能力（就像 css modules 的处理那样）。这种办法想想就知道成本很高，而且魔改了 ts server 对以后迁移和升级 ts 可能也会带来阻碍。所以这种方案简单调研了一下就毫不犹豫放弃了。</p> <p>最终，关于 global state 的问题，我是没有找到合适的方案。最后的写法是在 selector 处手动引入对应的 state，就像这样：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> value <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useSelector</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> test <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token punctuation">{</span> test<span class="token operator">:</span> TestState <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> test<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>写起来虽然不如 global state 那样简洁优雅，但是起码类型检查还在，也只能这样了。</p> <h2 id="自动推导-model-类型？"><a href="#自动推导-model-类型？" class="header-anchor">#</a> 自动推导 model 类型？</h2> <p>总结一下上面的点，最终关于 model 的类型补全，大致长这样：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 推导出action的工具类型</span>
<span class="token keyword">type</span> <span class="token class-name">GenerateAction<span class="token operator">&lt;</span><span class="token constant">M</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token operator">...</span>

<span class="token comment">// 推导出commands的工具类型</span>
<span class="token keyword">type</span> <span class="token class-name">Commands<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token operator">...</span>

<span class="token comment">// 单独写state的类型方便下面引用</span>
<span class="token keyword">type</span> <span class="token class-name">TestState</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 完成model的类型定义</span>
<span class="token keyword">type</span> <span class="token class-name">TestModel</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  namespace<span class="token operator">:</span> <span class="token string">'test'</span><span class="token punctuation">;</span>
  state<span class="token operator">:</span> TestState<span class="token punctuation">;</span>
  reducers<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>state<span class="token operator">:</span> TestState<span class="token punctuation">,</span> action<span class="token operator">:</span> <span class="token punctuation">{</span> payload<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> TestState<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  effects<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">bar</span><span class="token punctuation">(</span>action<span class="token operator">:</span> <span class="token punctuation">{</span> payload<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> commands<span class="token operator">:</span> Commands<span class="token operator">&lt;</span>TestAction<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 完成action的类型推导</span>
<span class="token keyword">export</span> TestAction <span class="token operator">=</span> GenerateAction<span class="token operator">&lt;</span>TestModel<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// 最后是model的具体代码</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> testModel<span class="token operator">:</span> TestModel <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>（完整的代码太长了这里就不贴出了，如果感兴趣可以留言）</p> <p>这个写法有个不足的地方，那就是需要手动先把 model 的类型写出来。能否把这个过程直接省略了呢？比如像这样：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> testModel <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">TestModel</span> <span class="token operator">=</span> GenerateModel<span class="token operator">&lt;</span><span class="token keyword">typeof</span> testModel<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">TestAction</span> <span class="token operator">=</span> GenerateAction<span class="token operator">&lt;</span>TestModel<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre></div><p>起初我觉得可以参考 vue 的类型推导那样，利用函数泛型实现 model 的自动类型推导，比如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// 一个工具类型</span>
<span class="token keyword">type</span> <span class="token class-name">Model<span class="token operator">&lt;</span><span class="token constant">N</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">R</span><span class="token punctuation">,</span> <span class="token constant">E</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  namespace<span class="token operator">:</span> <span class="token constant">N</span><span class="token punctuation">;</span>
  state<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">;</span>
  reducers<span class="token operator">:</span> <span class="token constant">R</span><span class="token punctuation">;</span>
  effects<span class="token operator">:</span> <span class="token constant">E</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 利用函数泛型的推导效果自动推导出namespace、state、reducers、effects的类型</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">descModel</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">N</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">R</span><span class="token punctuation">,</span> <span class="token constant">E</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>namespace<span class="token operator">:</span> <span class="token constant">N</span><span class="token punctuation">,</span> state<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">,</span> reducers<span class="token operator">:</span> <span class="token constant">R</span><span class="token punctuation">,</span> effects<span class="token operator">:</span> <span class="token constant">E</span><span class="token punctuation">)</span><span class="token operator">:</span> Model<span class="token operator">&lt;</span><span class="token constant">N</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">R</span><span class="token punctuation">,</span> <span class="token constant">E</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> namespace<span class="token punctuation">,</span> state<span class="token punctuation">,</span> reducers<span class="token punctuation">,</span> effects <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 利用descModel函数构造model的同时也构造出了model的类型</span>
<span class="token keyword">const</span> testModel <span class="token operator">=</span> <span class="token function">descModel</span><span class="token punctuation">(</span>
  <span class="token string">'test'</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// 在这里写清楚reducer和effect的类型定义</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token punctuation">{</span> payload <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token punctuation">{</span> payload<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token operator">*</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">{</span> payload <span class="token punctuation">}</span><span class="token operator">:</span> <span class="token punctuation">{</span> payload<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> commands<span class="token operator">:</span> Commands<span class="token operator">&lt;</span><span class="token keyword">typeof</span> testModel<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>实际上这里是有问题的，<code>bar</code>的 commands 参数的类型依赖于 model 的类型，而 model 的类型又依赖于<code>bar</code>的类型，于是产生了类型递归。ts 在一定程度上允许递归类型，但这种显然过于复杂无法支持，结果就是类型推导崩溃了，最后 fallback 到了 any，ts 的报错是这样描述的：</p> <div class="language- extra-class"><pre class="language-text"><code>has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
</code></pre></div><p>我尝试了很多种写法想解决这个问题，但都失败了，也许从根本上来讲，这种递归类型确实是无法实现的。如果确实是这样，那么自动推导出 model 的类型这个想法也是无法实现的。</p> <p>如果你有好的办法，欢迎告诉我。</p> <h2 id="后记"><a href="#后记" class="header-anchor">#</a> 后记</h2> <p>整个迁移过程遇到了很多坑，这里只是把印象比较深刻记录了一下，其实还有蛮多小问题的。比如有个 eslint 的报错：<code>Missing return type on function.eslint@typescript-eslint/explicit-module-boundary-types</code>，这个问题查到后面发现原来是 eslint 的一个 rule 的 bug，至今也没有彻底解决，最后只得把这个规则给 disable 掉了。</p> <p>总的来看，Dva 的 ts 迁移体验一点也不爽，主要是因为两点吧，一是 Dva 使用了约定式写法，这导致很多 ts 的静态检查很难发挥作用，所有采用约定式写法的框架都会遇到这个问题。二是 Dva 底层依赖 redux-saga，generator 的问题注定了类型推导无法平滑实现，只能打补丁。</p> <p>而以上两点，都是从原理上注定了无法体面地改善和优化。所以我想这也是为什么 Dva 官方至今一直没有给出 ts 参考实践的一个原因吧，不是不想弄，而是确实弄不了。</p> <p><img src="/blog/assets/img/js-and-ts.db3288e5.png" alt="js and ts"></p></div></div> <div class="comment" data-v-63da4bd6><!----></div></div></div> <div class="container" data-v-07c4fbe2 data-v-ad494eec>
  Designed by <a href="/about" data-v-07c4fbe2>Lishunyang</a> | <a href="https://beian.miit.gov.cn/" target="_blank" data-v-07c4fbe2>京ICP备20009157号</a> | All right reserved
</div></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.c3af64bb.js" defer></script><script src="/blog/assets/js/3.6f4cefaa.js" defer></script><script src="/blog/assets/js/21.b446c399.js" defer></script>
  </body>
</html>
